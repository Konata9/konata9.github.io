<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Implementing a Simple Direction Animation with Vue3</title>
    <link href="/en/2024/02/28/2024/a-simple-direction-animation-by-vue3/"/>
    <url>/en/2024/02/28/2024/a-simple-direction-animation-by-vue3/</url>
    
    <content type="html"><![CDATA[<h1 id="Implementing-a-Simple-Direction-Animation-with-Vue3"><a href="#Implementing-a-Simple-Direction-Animation-with-Vue3" class="headerlink" title="Implementing a Simple Direction Animation with Vue3"></a>Implementing a Simple Direction Animation with Vue3</h1><p>This is an interesting requirement I recently encountered, where we need to display location markers (map pins) on a map based on data returned from the backend. Precision isn’t crucial; we just need to approximate the directions.</p><p>The effect is somewhat similar to map markers in games.<br><img src="/en/images/2024/vue3-animate-demo.gif" alt="Vue3 Animation Demo"></p><h2 id="Design-Approach"><a href="#Design-Approach" class="headerlink" title="Design Approach"></a>Design Approach</h2><p>Considering we don’t need high precision, we’ll use the simplest method of <code>div + css</code> to display and animate the location markers, and ensure basic functionality with a background image.</p><p>There are a total of 9 directions, including north, south, east, west, and the four corners. We’ll arrange them in a 3 * 3 grid layout. The location markers only need to appear within the corresponding <code>div</code>.</p><p>Finally, we’ll wrap these directions in a single <code>div</code> and set the background of the outer <code>div</code> to achieve the desired effect.<br><img src="/en/images/2024/direction-div-sample.png" alt="Direction Sample"></p><h2 id="Code-Implementation-and-Demo"><a href="#Code-Implementation-and-Demo" class="headerlink" title="Code Implementation and Demo"></a>Code Implementation and Demo</h2><p>Once we’ve outlined the concept, the code implementation is relatively straightforward. We’ve created a demo using Vue3 on CodeSandbox. Since the code is fairly simple, we won’t elaborate further here.</p><p>You can observe the changes in the location markers by selecting the corresponding directions.</p><iframe src="https://codesandbox.io/p/devbox/simple-direction-animation-demo-6rzg88?embed=1&file=%2Fsrc%2FApp.vue"  style="width:100%; height: 500px; border:0; border-radius: 4px; overflow:hidden;"  title="simple-direction-animation-demo"  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><p><a href="https://codesandbox.io/p/devbox/simple-direction-animation-demo-6rzg88?embed=1&file=/src/App.vue"><img src="https://codesandbox.io/static/img/play-codesandbox.svg" alt="Edit simple-direction-animation-demo"></a></p><h2 id="Expansion"><a href="#Expansion" class="headerlink" title="Expansion"></a>Expansion</h2><p>In this implementation, achieving a decent effect largely depends on the suitability of the background image. Factors such as image size and margins will affect the final result. For irregular terrains, using SVG or Canvas might yield better results, although it would increase code complexity.</p><p>Apart from directional markers, similar implementations can be extended to other scenarios such as seat indicators inside train carriages or parking space markers in parking lots.</p><p>(Translated by ChatGPT)</p>]]></content>
    
    
    <categories>
      
      <category>Front-end Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>Front-end</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Improving Git Flow for Managing Private TypeScript Dependencies on Bitbucket</title>
    <link href="/en/2024/02/11/2024/improve-git-flow-to-manage-ts-dependency-on-bitbucket-as-private-npm/"/>
    <url>/en/2024/02/11/2024/improve-git-flow-to-manage-ts-dependency-on-bitbucket-as-private-npm/</url>
    
    <content type="html"><![CDATA[<p>In our current workflow, Bitbucket serves both as a code repository and a private NPM repository. Installing dependencies via <code>git+ssh</code> and specifying a <code>tag</code> is very convenient for pure JavaScript projects.</p><p>As some dependencies started using TypeScript, we need to manage them in one of the following ways:</p><ol><li>Directly commit the compiled <code>dist</code> files to the main&#x2F;master branch.</li><li>Compile during <code>postinstall</code>. Upon dependency installation, it automatically compiles.</li></ol><p>However, both methods have their drawbacks.</p><ul><li>Directly committing <code>dist</code> to the main branch adds many extra files during code review, making the project structure less elegant.</li><li>Using <code>postinstall</code> requires installing <code>typescript</code> additionally for pure JavaScript projects, which is also not elegant.</li></ul><p>Considering the manpower and repository migration costs (we have nearly 100 dependencies, each with many versions and used by different services), we can only address these issues by improving Git flow.</p><h2 id="Objectives"><a href="#Objectives" class="headerlink" title="Objectives"></a>Objectives</h2><p>The redesigned Git flow should meet the following objectives:</p><ol><li>Development branches should not contain compiled <code>dist</code> files.</li><li>Compilation should not rely on <code>postinstall</code>.</li><li>Dependency installation should remain unchanged, still via <code>git+ssh</code> and specifying <code>tag</code>.</li><li>Consideration for <code>hotfix</code> scenarios.</li></ol><h2 id="Improved-Git-Flow"><a href="#Improved-Git-Flow" class="headerlink" title="Improved Git Flow"></a>Improved Git Flow</h2><p>To achieve the above objectives, here is the improved Git flow:<br><img src="/en/images/2024/improved-git-flow.jpg" alt="Improved Git Flow"></p><p>For regular development, after merging code into <code>master</code>, we first push the <code>src</code> tag and modify <code>.gitignore</code> to temporarily create a <code>build</code> branch. Then, we compile on the <code>build</code> branch and tag it formally, including the <code>dist</code> files, which can be referenced by other services.</p><p>When a <code>hotfix</code> is needed, we can branch off from the corresponding <code>src</code> tag to fix and then merge back into the <code>master</code> branch following the same steps.</p><h2 id="Pipeline-Script-Configuration"><a href="#Pipeline-Script-Configuration" class="headerlink" title="Pipeline Script Configuration"></a>Pipeline Script Configuration</h2><p>The Git flow described above involves tagging, modifying <code>.gitignore</code>, compiling, and then releasing after code merges. Even with documentation, it’s prone to errors in practice. Thus, it’s crucial to automate these steps using <a href="https://support.atlassian.com/bitbucket-cloud/docs/build-test-and-deploy-with-pipelines/">Bitbucket Pipeline</a> upon merging code into the <code>master</code> branch.</p><p>Here is an example:</p><ol><li>Pipeline section:</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">branches:</span><br>  <span class="hljs-attr">master:</span> <span class="hljs-comment"># Trigger only when merging into the main branch</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">step:</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">build</span><br>        <span class="hljs-attr">deployment:</span> <span class="hljs-string">Build</span> <span class="hljs-comment"># Execute as Deployment, the name can be arbitrary</span><br>        <span class="hljs-attr">script:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">remote</span> <span class="hljs-string">set-url</span> <span class="hljs-string">origin</span> <span class="hljs-string">$&#123;BITBUCKET_GIT_SSH_ORIGIN&#125;</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">./scripts/build.sh</span><br></code></pre></td></tr></table></figure><ol start="2"><li>Tagging and compilation script:</li></ol><p>The build.sh script in the pipeline is the core of the Git flow. It tags the source, compiles, and pushes the compiled formal tag.</p><p>The version of the tag follows semver rules, with the current tag being fetched from package.json’s version. The next version is derived from the prefix of the branch name, e.g., for major&#x2F;xxxx, the next version increments the major version; for feature&#x2F;xxx, it increments the minor version. It uses npm version command to upgrade the tag.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/usr/bin/env bash</span><br><br><span class="hljs-built_in">set</span> -e<br><span class="hljs-comment"># Create tags in the bitbucket pipline, env from bitbucket pipeline</span><br>source_branch=$(git <span class="hljs-built_in">log</span> --format=%B -n 1 <span class="hljs-variable">$BITBUCKET_COMMIT</span> | awk <span class="hljs-string">&#x27;&#123;print $3&#125;&#x27;</span>)<br><br><span class="hljs-keyword">if</span> [[ -n <span class="hljs-variable">$source_branch</span> ]]; <span class="hljs-keyword">then</span><br>  <span class="hljs-comment"># PART 1: Get the next tag</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Triggered by pull request <span class="hljs-variable">$&#123;source_branch&#125;</span>&quot;</span><br><br>  <span class="hljs-keyword">if</span> [[ <span class="hljs-variable">$&#123;source_branch&#125;</span> == feature/* ]]; <span class="hljs-keyword">then</span><br>    level=minor<br>  <span class="hljs-keyword">elif</span> [[ <span class="hljs-variable">$&#123;source_branch&#125;</span> == bugfix/* ]]; <span class="hljs-keyword">then</span><br>    level=patch<br>  <span class="hljs-keyword">elif</span> [[ <span class="hljs-variable">$&#123;source_branch&#125;</span> == hotfix/* ]]; <span class="hljs-keyword">then</span><br>    level=prerelease<br>  <span class="hljs-keyword">elif</span> [[ <span class="hljs-variable">$&#123;source_branch&#125;</span> == major/* ]]; <span class="hljs-keyword">then</span><br>    level=major<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Nothing happen on branch: <span class="hljs-variable">$&#123;BITBUCKET_BRANCH&#125;</span>&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Source branch: <span class="hljs-variable">$&#123;source_branch&#125;</span>&quot;</span><br>  <span class="hljs-keyword">fi</span><br><br>  <span class="hljs-keyword">if</span> [[ ! -z <span class="hljs-variable">$&#123;level&#125;</span> ]]; <span class="hljs-keyword">then</span><br>    <span class="hljs-comment"># PART 2: Create src-tag and push back</span><br>    current_version=$(node -e <span class="hljs-string">&quot;console.log(require(&#x27;./package.json&#x27;).version)&quot;</span>) &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Current version - <span class="hljs-variable">$&#123;current_version&#125;</span>&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Crated version on branch: <span class="hljs-variable">$&#123;BITBUCKET_BRANCH&#125;</span>. Tag: <span class="hljs-variable">$&#123;current_version&#125;</span>&quot;</span><br><br>    next_version=$(npx semver <span class="hljs-variable">$&#123;current_version&#125;</span> -i <span class="hljs-variable">$&#123;level&#125;</span>)<br>    source_tag=v<span class="hljs-variable">$&#123;next_version&#125;</span>-src<br><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Build source tag: <span class="hljs-variable">$&#123;source_tag&#125;</span> on branch: <span class="hljs-variable">$&#123;BITBUCKET_BRANCH&#125;</span>&quot;</span><br>    <span class="hljs-comment"># Create the source tag and push back</span><br>    npm version <span class="hljs-variable">$&#123;next_version&#125;</span> --no-git-tag-version <span class="hljs-comment"># This will not create a git tag just update the version in the package.json</span><br><br>    git add --all<br>    git commit -m <span class="hljs-string">&quot;[skip ci] <span class="hljs-variable">$&#123;current_version&#125;</span> --&gt; <span class="hljs-variable">$&#123;next_version&#125;</span>&quot;</span> <span class="hljs-comment"># [skip ci] Will not trigger this pipeline again</span><br>    git tag -am <span class="hljs-string">&quot;[skip ci] source tag: <span class="hljs-variable">$&#123;source_tag&#125;</span>&quot;</span> <span class="hljs-variable">$&#123;source_tag&#125;</span><br>    git push origin <span class="hljs-variable">$&#123;BITBUCKET_BRANCH&#125;</span> <span class="hljs-variable">$&#123;source_tag&#125;</span><br><br>    <span class="hljs-comment"># PART 3: Add the dist folder and create release tag</span><br>    <span class="hljs-comment"># Add the dist folder</span><br>    sed -i <span class="hljs-string">&#x27;s/dist//g&#x27;</span> .gitignore<br><br>    <span class="hljs-comment"># build ts</span><br>    npm run build<br><br>    <span class="hljs-comment"># push to tag</span><br>    git add --all<br>    git commit -m <span class="hljs-string">&quot;[skip ci] Build release tag: <span class="hljs-variable">$&#123;next_version&#125;</span> on branch: <span class="hljs-variable">$&#123;BITBUCKET_BRANCH&#125;</span>&quot;</span><br>    git tag -am <span class="hljs-string">&quot;[skip ci] release tag: <span class="hljs-variable">$&#123;next_version&#125;</span>&quot;</span> <span class="hljs-variable">$&#123;next_version&#125;</span> <span class="hljs-comment"># only push the tag</span><br>    git push origin refs/tags/<span class="hljs-variable">$&#123;next_version&#125;</span><br>  <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><div class="note note-info">            <p>It’s recommended to execute Shell scripts within the Deployment section because it’s a blocking queue, ensuring only one script runs at a time, thus avoiding tag duplication issues.</p><p>Also, certain naming restrictions should be imposed on development branches, for instance, using tools like Husky.</p>          </div><h2 id="Expansion"><a href="#Expansion" class="headerlink" title="Expansion"></a>Expansion</h2><p>This Git flow can be applied in any code hosting tool, even without triggering methods like Pipeline&#x2F;GitAction; it can still be achieved by running scripts. It also enables automatic tagging.</p><p>Although there’s no perfect Git flow, a suitable one can standardize our work and enhance efficiency.</p><p>(Translated by ChatGPT)</p>]]></content>
    
    
    <categories>
      
      <category>Program learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>npm</tag>
      
      <tag>nodejs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo i18n support transformation</title>
    <link href="/en/2024/01/17/2024/update-hexo-i18n/"/>
    <url>/en/2024/01/17/2024/update-hexo-i18n/</url>
    
    <content type="html"><![CDATA[<p>In my work, most of the documents I search and refer to are in English. So, I thought of update my blog to support multiple languages, and at the same time, consider it as a good start for the new year.</p><h2 id="Objectives"><a href="#Objectives" class="headerlink" title="Objectives"></a>Objectives</h2><p>The goals for this transformation are twofold:</p><ol><li>Global support for multiple languages (Chinese and English).</li><li>Switching between different languages seamlessly.</li></ol><h2 id="Exploration"><a href="#Exploration" class="headerlink" title="Exploration"></a>Exploration</h2><p>Although hexo and the <a href="https://theme-next.js.org/">NexT</a> theme I used before have i18n support, it mainly covers fixed content like navigation and menus and lacks comprehensive global support.</p><p>After searching online, I found roughly three solutions:</p><table><thead><tr><th>No.</th><th>Solution</th><th>Pros</th><th>Cons</th></tr></thead><tbody><tr><td>1</td><td>Create an <code>en</code> folder under <code>_post</code> to store English articles.</td><td>Simple and clear, no additional changes required.</td><td>The blog homepage will display all articles. Additional development is needed for language-specific display.</td></tr><tr><td>2</td><td>Use the <a href="https://github.com/Jamling/hexo-generator-i18n/tree/master">hexo-generator-i18n</a> plugin.</td><td>Simple, just install and configure.</td><td>1. The plugin has not been updated for a long time.<br/>2. Additional development is required after installing the plugin, such as language switching.</td></tr><tr><td>3</td><td>Create two separate websites for different language versions.</td><td>Relatively simple and completely independent.</td><td>Some configuration and code redundancy between the two websites.</td></tr></tbody></table><p>Considering the ease of operation and maintenance (mainly laziness, not wanting to develop further), I decided to go with the third solution.</p><p>During my research, I also came across the <a href="https://hexo.fluid-dev.com/docs/">Fluid</a> theme, which felt comfortable, so I took this opportunity to upgrade it as well.</p><h2 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h2><p>Under the folder of the new blog, I used <code>hexo init</code> to create two blogs for each language. The directory structure is as follows:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">.<br>├── blog-cn<br>├── blog-en<br>└── scripts<br></code></pre></td></tr></table></figure><p>For configurations related to the Fluid theme and multilingual support, please refer to: <a href="https://www.brando.dev/zh-hans/2021/01/03/%E8%AE%B0%E4%B8%80%E6%AC%A1-Hexo-%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E4%B8%8E%E5%A4%9A%E8%AF%AD%E8%A8%80%E7%AB%99%E7%82%B9%E6%94%B9%E9%80%A0/">A Detailed Account of Hexo Blog Migration and Multilingual Site Transformation</a>. The article provides a comprehensive and detailed guide, allowing for a step-by-step implementation.</p><p>Regarding the deployment aspect, you may refer to: <a href="https://tstrs.me/1448.html">Hexo Adding Multilingual Support “Internationalization i18n”</a>. The deployment process has been consolidated into a <code>shell</code> script, making it a more straightforward read and facilitating the deployment process.</p><p>Fundamentally, the addition involves creating an <code>en</code> folder in the compiled files, storing English content. Consequently, you can access it through <code>https://&#123;your-blog&#125;/en</code>.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Build CN blog</span><br>cd blog-cn &amp;&amp; pnpm run build<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Build En blog</span><br>cd ../blog-en &amp;&amp; pnpm run build<br><br>cd ../blog-cn<br>mkdir ./public/en &amp;&amp;mv ../blog-en/public/* ./public/en/<br><br>pnpm run deploy<br></code></pre></td></tr></table></figure><h2 id="Migration"><a href="#Migration" class="headerlink" title="Migration"></a>Migration</h2><p>Migrating hexo is the easiest task in this process. Simply copy the necessary files from the <code>source</code> directory to the new location.</p><h2 id="Other-Considerations"><a href="#Other-Considerations" class="headerlink" title="Other Considerations"></a>Other Considerations</h2><p>The remaining task is translation work. Let’s explore whether we can leverage the power of Google Translate or GPT.</p><p>Finally, feel free to visit my <a href="https://konata9.github.io/">updated blog</a> for some recreational reading.</p><p>(Translated by ChatGPT)</p>]]></content>
    
    
    <categories>
      
      <category>Program learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>i18n</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
