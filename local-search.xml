<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>从开发的视角聊聊 AI 带来感受与变化</title>
    <link href="/2024/03/21/2024/view-from-programmer-of-ai/"/>
    <url>/2024/03/21/2024/view-from-programmer-of-ai/</url>
    
    <content type="html"><![CDATA[<p>一个 4 年没做前端的 <strong>“前”</strong> 前端开发，在 ChatGPT（3.5）的帮助下，只用了一个下午就用 Vue3 + Vuetify 完成了 3 个完整带交互的页面。</p><p>提交代码后最直观的感受是：<strong>前端要被代替了</strong> 。放在 4 年前，同样的需求在不熟悉 Vue3 的前提下至少需要 2 天左右的时间。如此巨大的变化，让我有点庆幸还好转去了后端。但，后端就不会被代替吗？</p><h2 id="AI-的冲击"><a href="#AI-的冲击" class="headerlink" title="AI 的冲击"></a>AI 的冲击</h2><p>自 ChatGPT 问世之后，世界像被按下了加速键。Claude、Copilot、MidJourney 一众 AI 产品开始有意无意地改变我们的工作与生活。</p><p>最近在 InfoQ 的公众上看到了下面这篇文章：<a href="https://mp.weixin.qq.com/s/ss1uzFTLKynGXxM0M5RO0Q">敲了17年代码，我现在连个面试机会都得不到</a><br><img src="/images/2024/job-of-engineer.png" alt="职位需求的变化"></p><p>对于职位需求的变化，文章提到：</p><blockquote><p>例如，后端工程师的职位空缺仅下降了 14%，而前端工程师的职位空缺则减少达 24%。Henley Wing Chiu 认为这里很可能存在“AI 效应”，因为企业需要稳定且可扩展的后端来部署大语言模型等机器学习艺术形式。而另一方面，投资建设 AI 体系并不需要强大的前端技能。无论我们使用 Angular 还是 React，对机器学习艺术形式的性能都没什么实质影响。</p></blockquote><p>回到上面的问题，看来后端也会被代替，只是时间问题。但，这个时间是多久呢？</p><p>在我还没有进一步思考的时候。就看到了 AI 程序员 Devin 的消息。在这篇文章的描述中，已经可以和人问答修 debug 了。文章：<a href="https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&mid=2650587922&idx=1&sn=34bb9daa8f83c888cd56719665aa1341&chksm=f1fe7591c689fc874478b1325afcb14034728e015d5ea80411360de542474d8bbce4c2b7e594&mpshare=1&srcid=0319xxdLz0m7h3kE0mjyYCni&sharer_shareinfo=8fdb202127ee606f2787948f1de772f6&sharer_shareinfo_first=8fdb202127ee606f2787948f1de772f6&from=groupmessage&scene=1&subscene=93&clicktime=1710842925&enterid=1710842925&sessionid=0&ascene=1&fasttmpl_type=0&fasttmpl_fullversion=7124241-zh_CN-zip&fasttmpl_flag=0&realreporttime=1710842925330&devicetype=pad-android-34&version=28002f3f&nettype=ctnet&lang=zh_CN&countrycode=CN&exportkey=n_ChQIAhIQ9sHPkojDansr/ywVoW/A3hLuAQIE97dBBAEAAAAAAM6ABmVtmZUAAAAOpnltbLcz9gKNyK89dVj0tK1VcCwpq9051P458SHdp1w+xn2ZldqZDVhX+OfAhWNNQtP4Y348LHkgzJBblxIzKyPYrNG5WVdrWRQXw0QNyZDpJofMzh8/dD+6femoZIo08TPxqjCDNWMT7BIWLu6P61CgNiIxTHFtJcxlPg2CIJeeZ0LRfnqJLMayauZJH0zXA77vzNFrSlhN5GWOvxO0+SmYy3fXnZalmgUpdCZXN0tl/oXBS4yX9iiKNp73n/ZNcnpaV88YRglQRUiylzjZ2SVfB73xwJw=&pass_ticket=Pe6WDz7TOqYpaO2U8hNqL1rCG5argJ0uVtooCPh4fMqpxDfiodplaqel9BZOFBL/G+Ll2ABcv3zS6HPyw0p3xQ==&wx_header=3">AI程序员Devin卧底工作群修bug！和CTO聊技术，网友：顶级码农水平</a></p><p><img src="/images/2024/devin-chat.png"></p><p>很难想象 Devin 开放公测后，求职市场会有怎样的变化。开源版的 <a href="https://github.com/OpenDevin/OpenDevin">OpenDevin</a> 也已经获得高赞，相信相关的应用在不久后也会出现。</p><p>所以是准备躺平还是再挣扎一下呢？或许还有哪些我们还没有看到的。</p><h2 id="AI-带来的机会"><a href="#AI-带来的机会" class="headerlink" title="AI 带来的机会"></a>AI 带来的机会</h2><p>毕竟 AI 出现的初衷还是为了更好的帮助人类，解放生产力。这篇文章 <a href="https://www.geekpark.net/news/332526">我，一个技术公司的普通行政，成了公司的 AI 产品专家</a> 让我看到了另一面。</p><blockquote><p>这就是 AI 带来的伟大变化。我认为它能快速帮某领域的非专业人员达到中等专业水平——未来很多岗位的限制，可能都会因为初阶技能的消失而打通。</p><p>这可能会对一些职业产生冲击，比如程序员可能会忧心忡忡，自己仅靠写代码完成需求的时代，是否一去不复返了？</p><p>但反过来说，这也是个体的机会。</p><p>未来很有可能是一个 AI 超级单兵的时代——只要你有想法、创意，其他的事情都可以让 AI 帮你完成。</p></blockquote><p>再次回到前面的问题，前端&#x2F;后端会被代替吗？</p><p>我觉得会，但不完全会。</p><p>需求明确的工作会被代替或者说由 AI 来执行，比如<a href="https://konata9.github.io/2024/03/17/2024/a-simple-scale-animation-by-vue3/">之前文章</a>中实现的动画效果、页面布局，以及如一些批处理的脚本命令等。越是明确的需求，GPT 的回答就越准确。作为直面用户的前端，页面上的需求是十分明确的。</p><p>反之，一些需要抽象的工作就不容易被替代。比如代码结构的组织、功能层级的划分以及架构设计等工作。这部分工作需要在项目需求、应用场景、历史包袱、人员成本等各种因素中做折中和平衡。自然语言都描述不清楚的需求，AI 自然也很难给到合适结果。</p><p>但可以看到的是，在 AI 的加持下，技术的门槛正在被削弱、执行某件事的阻力变小了。取而代之的是，如何将需求转换为提示词的能力开始变得重要。</p><p>试想当今后的工作会逐渐由 AI 来完成细节部分，人类进行检查并完成抽象部分，生产力将会得到极大的解放。目前 Copilot，Codeium 等编码辅助 AI 已经可以完成 JSDoc、函数补全甚至单元测试了。</p><h2 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h2><p>生产力的解放一方面可以让个人完成更多的事情，另一方面会带来产能过剩的问题。只看周围，或许暂时并没有多大的变化。该做的需求还是要做，该修的 bug 还是要修。但靴子终究有落地的时候，或早或晚。作为普通人，即使没法应对，也应有所准备。</p><p>引用前面<a href="https://www.geekpark.net/news/332526">文章</a>的结尾，与各位共勉。</p><blockquote><p>AI 这个词很大，它能达到的高度也是目前难以望及的。我觉得作为普通人，想法和行动可以朴素一些：就是把手头的活，与 AI 结合好，一点点来。慢慢地，你会发现自己融入了这波技术洪流，并被它推至一个前所未有的世界。这件事确实让人兴奋。</p></blockquote><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>敲了17年代码，我现在连个面试机会都得不到](<a href="https://mp.weixin.qq.com/s/ss1uzFTLKynGXxM0M5RO0Q">https://mp.weixin.qq.com/s/ss1uzFTLKynGXxM0M5RO0Q</a>)<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&mid=2650587922&idx=1&sn=34bb9daa8f83c888cd56719665aa1341&chksm=f1fe7591c689fc874478b1325afcb14034728e015d5ea80411360de542474d8bbce4c2b7e594&mpshare=1&srcid=0319xxdLz0m7h3kE0mjyYCni&sharer_shareinfo=8fdb202127ee606f2787948f1de772f6&sharer_shareinfo_first=8fdb202127ee606f2787948f1de772f6&from=groupmessage&scene=1&subscene=93&clicktime=1710842925&enterid=1710842925&sessionid=0&ascene=1&fasttmpl_type=0&fasttmpl_fullversion=7124241-zh_CN-zip&fasttmpl_flag=0&realreporttime=1710842925330&devicetype=pad-android-34&version=28002f3f&nettype=ctnet&lang=zh_CN&countrycode=CN&exportkey=n_ChQIAhIQ9sHPkojDansr/ywVoW/A3hLuAQIE97dBBAEAAAAAAM6ABmVtmZUAAAAOpnltbLcz9gKNyK89dVj0tK1VcCwpq9051P458SHdp1w+xn2ZldqZDVhX+OfAhWNNQtP4Y348LHkgzJBblxIzKyPYrNG5WVdrWRQXw0QNyZDpJofMzh8/dD+6femoZIo08TPxqjCDNWMT7BIWLu6P61CgNiIxTHFtJcxlPg2CIJeeZ0LRfnqJLMayauZJH0zXA77vzNFrSlhN5GWOvxO0+SmYy3fXnZalmgUpdCZXN0tl/oXBS4yX9iiKNp73n/ZNcnpaV88YRglQRUiylzjZ2SVfB73xwJw=&pass_ticket=Pe6WDz7TOqYpaO2U8hNqL1rCG5argJ0uVtooCPh4fMqpxDfiodplaqel9BZOFBL/G+Ll2ABcv3zS6HPyw0p3xQ==&wx_header=3">AI程序员Devin卧底工作群修bug！和CTO聊技术，网友：顶级码农水平</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://www.geekpark.net/news/332526">我，一个技术公司的普通行政，成了公司的 AI 产品专家</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>随想杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>程序员</tag>
      
      <tag>AI</tag>
      
      <tag>开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3 实现一个简单的放大动画</title>
    <link href="/2024/03/17/2024/a-simple-scale-animation-by-vue3/"/>
    <url>/2024/03/17/2024/a-simple-scale-animation-by-vue3/</url>
    
    <content type="html"><![CDATA[<p>这是之前<a href="https://konata9.github.io./2024/02/28/2024/a-simple-direction-animation-by-vue3/">方位动画</a>的衍生需求。先根据后端返回的数据排列内容，然后当用户点击某块内容后居中放大并根据具体的方位数据显示方位动画。</p><p>可以参考下面的效果。<br><img src="/images/2024/vue3-scale-animate-demo.gif" alt="demo动画"></p><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>定位动画我们在之前已经实现了。那么这里只要考虑如何实现放大动画，最后将两者结合起来就好。从后端拿到的返回值是一个固定长度的数组，所以这里还是用 <code>div</code> 利用 <code>flex</code> 布局将图片平铺展示，利用 CSS <code>transform</code> 进行位置移动和缩放。</p><p>接下来就是如何计算出每个 <code>div</code> 的位移。DOM 元素的位移主要关注左上角顶点的位移。针对这个需求可以画出如下草图。外层 <code>div</code> 为 container，内层 <code>div</code> 为 inner。</p><p><img src="/images/2024/transform-calculate.jpg" alt="计算草图"></p><p>从上图可以看到，每个 <code>div</code> 的位移即 <code>center.left - inner.left</code>, <code>center.top - inner.top</code>.<br>container 的中心点:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> containerCenterX = containerRect.<span class="hljs-property">left</span> + containerRect.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">const</span> containerCenterY = containerRect.<span class="hljs-property">top</span> + containerRect.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>inner 移动的偏移量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 让 inner 移到 container 的正中间</span><br><span class="hljs-keyword">const</span> offsetX = containerCenterX - itemRect.<span class="hljs-property">width</span> / <span class="hljs-number">2</span> - itemRect.<span class="hljs-property">left</span>;<br><span class="hljs-keyword">const</span> offsetY = containerCenterY - itemRect.<span class="hljs-property">height</span> / <span class="hljs-number">2</span> - itemRect.<span class="hljs-property">top</span>;<br></code></pre></td></tr></table></figure><p>最后将方位动画的 <code>div</code> 叠在 <code>inner</code> 上面即可。</p><h2 id="代码实现和-Demo-演示"><a href="#代码实现和-Demo-演示" class="headerlink" title="代码实现和 Demo 演示"></a>代码实现和 Demo 演示</h2><p>梳理清思路之后，就可以实现代码了。Demo 已经放在 CodeSandbox 上了。其中最主要的还是位移计算的逻辑。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">showActiveImage</span> = (<span class="hljs-params">imageEl</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> containerEl = container.<span class="hljs-property">value</span>;<br><br>  <span class="hljs-keyword">const</span> containerRect = containerEl!.<span class="hljs-title function_">getBoundingClientRect</span>();<br>  <span class="hljs-keyword">const</span> itemRect = imageEl!.<span class="hljs-title function_">getBoundingClientRect</span>();<br><br>  <span class="hljs-keyword">const</span> containerCenterX = containerRect.<span class="hljs-property">left</span> + containerRect.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">const</span> containerCenterY = containerRect.<span class="hljs-property">top</span> + containerRect.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>;<br><br>  <span class="hljs-keyword">const</span> offsetX = containerCenterX - itemRect.<span class="hljs-property">width</span> / <span class="hljs-number">2</span> - itemRect.<span class="hljs-property">left</span>;<br>  <span class="hljs-keyword">const</span> offsetY = containerCenterY - itemRect.<span class="hljs-property">height</span> / <span class="hljs-number">2</span> - itemRect.<span class="hljs-property">top</span>;<br><br>  imageEl!.<span class="hljs-property">style</span>.<span class="hljs-property">transform</span> = <span class="hljs-string">`translate(<span class="hljs-subst">$&#123;offsetX&#125;</span>px, <span class="hljs-subst">$&#123;offsetY&#125;</span>px) scale(1.2)`</span>;<br>  imageEl!.<span class="hljs-property">style</span>.<span class="hljs-property">zIndex</span> = <span class="hljs-number">100</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><iframe src="https://codesandbox.io/p/devbox/simple-scale-animation-demo-vjhsyh?embed=1&file=%2Fsrc%2FApp.vue"  style="width:100%; height: 500px; border:0; border-radius: 4px; overflow:hidden;"  title="simple-scale-animation-demo"  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><p><a href="https://codesandbox.io/p/devbox/simple-scale-animation-demo-vjhsyh?file=/src/App.vue&embed=1"><img src="https://codesandbox.io/static/img/play-codesandbox.svg" alt="Edit simple-scale-animation-demo"></a></p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>这次的需求也可以用于展示动画。比如产品展示或者局部细节的展示。根据不同的需求结合不同的动画，可以让我们的页面变得更加酷炫。</p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>其实这两次的动画效果，代码都是利用 ChatGPT 生成的，我自己基本没有什么参与。在 4 年前我就从前端转到了后端，因此对于前端方面的知识还停留在很久之前。但有了 ChatGPT 的加持，我也可以用当前的前端技术实现一些需求。</p><p>尽管这次的需求比较简单，但通过实践可以发现，利用好 AI 能够拓宽我们的技术面，让我们做到更多事情。但于此同时，作为开发者也应当思考与 AI 之间的关系了，这又是另一个话题了</p>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3 实现一个简单的方位动画</title>
    <link href="/2024/02/28/2024/a-simple-direction-animation-by-vue3/"/>
    <url>/2024/02/28/2024/a-simple-direction-animation-by-vue3/</url>
    
    <content type="html"><![CDATA[<p>这是最近遇到的一个有点意思的需求，需要根据后端返回的数据，在一块地图的具体的方位上显示对应位置标识（位置图钉）。不用十分精确，只要能表现出大致的方位即可。</p><p>类似下面的效果，有点像游戏里的地图标识。<br><img src="/images/2024/vue3-animate-demo.gif"></p><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>由于不用十分精确，就用最简单的 <code>div + css</code> 来实现位置标识的显示和动画。之后再通过配合背景图片来保证最基础的效果。</p><p>方位总共 9 个，东南西北中加上四个角，通过 Grid 布局让其形成 3 * 3 的格子。位置标识只需要根据方位数据出现在对应的 <code>div</code> 中即可。</p><p>最后将这些方位用一个 <code>div</code> 包裹起来，只要设置外层 <code>div</code> 的背景即可实现。<br><img src="/images/2024/direction-div-sample.png"></p><h2 id="代码实现和-Demo-演示"><a href="#代码实现和-Demo-演示" class="headerlink" title="代码实现和 Demo 演示"></a>代码实现和 Demo 演示</h2><p>梳理清思路后，代码实现就比较简单了。这里用 Vue3 在 CodeSandbox 上实现这个 Demo，代码相对简单就不再展开赘述。</p><p>通过选择对应的方位，可以观察位置标识的变化。</p><iframe src="https://codesandbox.io/p/devbox/simple-direction-animation-demo-6rzg88?embed=1&file=%2Fsrc%2FApp.vue"  style="width:100%; height: 500px; border:0; border-radius: 4px; overflow:hidden;"  title="simple-direction-animation-demo"  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><p><a href="https://codesandbox.io/p/devbox/simple-direction-animation-demo-6rzg88?embed=1&file=/src/App.vue"><img src="https://codesandbox.io/static/img/play-codesandbox.svg" alt="Edit simple-direction-animation-demo"></a></p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>在这个实现下，要获得不错的效果主要依赖背景图片是否合适，图片大小、边缘留白等都会影响最终的效果。如果是针对不规则的地形组合，可能用 SVG 或 Canvas 来实现更好，但相对的代码复杂度也会上升。</p><p>除了方位标识，类似的实现也可以拓展到其他场景，比如车厢内的座位标识，停车场的车位标识等。</p>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>改进 Git flow 来管理 Bitbucket 上的私有 TypeScript 依赖</title>
    <link href="/2024/02/11/2024/improve-git-flow-to-manage-ts-dependency-on-bitbucket-as-private-npm/"/>
    <url>/2024/02/11/2024/improve-git-flow-to-manage-ts-dependency-on-bitbucket-as-private-npm/</url>
    
    <content type="html"><![CDATA[<p>在目前的工作中，Bitbucket 同时被我们用作代码仓库和私有 NPM 仓库。通过 <code>git+ssh</code> 指定 <code>tag</code> 来安装依赖，对于纯 JavaScript 的项目十分方便。</p><p>随着部分依赖开始使用 TypeScript，基于现有使用方式，需要对这部分依赖采取下面的一种方式进行管理。</p><ol><li>直接将编译后的 <code>dist</code> 文件提交到主分支上。</li><li>在 <code>postinstall</code> 中进行编译。当依赖被安装后，就会自动编译。</li></ol><p>但无论哪种方式，都会有一些瑕疵。</p><ul><li>直接将 <code>dist</code> 提交到主分支上，在做 Code review 时会额外多出许多文件干扰，项目结构也不优雅。</li><li>通过 <code>postinstall</code> 的方式对于纯 JavaScript 的项目就需要额外安装 <code>typescript</code>，同样不优雅。</li></ul><p>出于人力以及迁移仓库的成本考虑（我们有近 100 个依赖，且每个依赖有许多版本并且被不同的服务引用），对此只能通过改进 Git flow 来解决上述瑕疵。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>重新设计的 Git flow 需要满足以下目标。</p><ol><li>开发分支上不需要编译后 <code>dist</code> 文件。</li><li>不需要通过 <code>postinstall</code> 的方式来编译。</li><li>引用的方式不发生改变，还是通过 <code>git+ssh</code> 指定 <code>tag</code> 的方式安装依赖。</li><li>需要考虑到 <code>hotfix</code> 的情况。</li></ol><h2 id="Git-flow-改进"><a href="#Git-flow-改进" class="headerlink" title="Git flow 改进"></a>Git flow 改进</h2><p>为了实现上述目标，下面是改进后的 Git flow。<br><img src="/images/2024/improved-git-flow.jpg" alt="改进后的 Git flow"></p><p>对于正常的开发，当代码合并到 <code>master</code> 后，先推送 <code>src</code> tag 并修改 <code>.gitignore</code> 临时创建 <code>build</code> 分支。随后在 <code>build</code> 分支编译并且打上正式 tag，正式 tag 包含 <code>dist</code> 文件，可以被其他服务引用。</p><p>当需要进行 <code>hotfix</code> 时，就可以从对应的 <code>src</code> tag 上切出分支进行 fix，之后再以相同的步骤合入 <code>master</code> 分支。</p><h2 id="Pipeline-脚本设置"><a href="#Pipeline-脚本设置" class="headerlink" title="Pipeline 脚本设置"></a>Pipeline 脚本设置</h2><p>上述的 Git flow 在代码合并之后有打 tag、修改 <code>.gitignore</code>、编译再发布的步骤。即便有文档说明，在实际操作上也很容易出错。因此十分有必要将这些步骤自动化。利用 <a href="https://support.atlassian.com/bitbucket-cloud/docs/build-test-and-deploy-with-pipelines/">Bitbucket Pipeline</a> 在代码合入 <code>master</code> 分支时自动执行。</p><p>下面是示例代码。</p><ol><li>Pipeline 部分</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">branches:</span><br>  <span class="hljs-attr">master:</span> <span class="hljs-comment"># 当合入主分支时才会触发</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">step:</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">build</span><br>        <span class="hljs-attr">deployment:</span> <span class="hljs-string">Build</span> <span class="hljs-comment"># 以 Deployment 的方式执行，名字可以随意指定</span><br>        <span class="hljs-attr">script:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">remote</span> <span class="hljs-string">set-url</span> <span class="hljs-string">origin</span> <span class="hljs-string">$&#123;BITBUCKET_GIT_SSH_ORIGIN&#125;</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">./scripts/build.sh</span> <span class="hljs-comment"># 实际执行的脚本</span><br></code></pre></td></tr></table></figure><ol start="2"><li>打 tag 以及编译脚本。</li></ol><p>pipeline 中的 <code>build.sh</code>，整个 Git flow 的核心。实现打 src tag、编译以及推送编译后的正式 tag。</p><p>tag 的版本遵循 semver 规则，当前 tag 为 <code>package.json</code> 中的 <code>version</code>。下一个版本则来源于分支名的前缀，比如分支名为 <code>major/xxxx</code> 即下一个版本升级主版本号；如果是 <code>feature/xxx</code> 则为 <code>minor</code>。利用 <code>npm version</code> 命令升级标签。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/usr/bin/env bash</span><br><br><span class="hljs-built_in">set</span> -e<br><span class="hljs-comment"># Create tags in the bitbucket pipline, env from bitbucket pipeline</span><br>source_branch=$(git <span class="hljs-built_in">log</span> --format=%B -n 1 <span class="hljs-variable">$BITBUCKET_COMMIT</span> | awk <span class="hljs-string">&#x27;&#123;print $3&#125;&#x27;</span>)<br><br><span class="hljs-keyword">if</span> [[ -n <span class="hljs-variable">$source_branch</span> ]]; <span class="hljs-keyword">then</span><br>  <span class="hljs-comment"># PART 1: Get the next tag</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Triggered by pull request <span class="hljs-variable">$&#123;source_branch&#125;</span>&quot;</span><br><br>  <span class="hljs-keyword">if</span> [[ <span class="hljs-variable">$&#123;source_branch&#125;</span> == feature/* ]]; <span class="hljs-keyword">then</span><br>    level=minor<br>  <span class="hljs-keyword">elif</span> [[ <span class="hljs-variable">$&#123;source_branch&#125;</span> == bugfix/* ]]; <span class="hljs-keyword">then</span><br>    level=patch<br>  <span class="hljs-keyword">elif</span> [[ <span class="hljs-variable">$&#123;source_branch&#125;</span> == hotfix/* ]]; <span class="hljs-keyword">then</span><br>    level=prerelease<br>  <span class="hljs-keyword">elif</span> [[ <span class="hljs-variable">$&#123;source_branch&#125;</span> == major/* ]]; <span class="hljs-keyword">then</span><br>    level=major<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Nothing happen on branch: <span class="hljs-variable">$&#123;BITBUCKET_BRANCH&#125;</span>&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Source branch: <span class="hljs-variable">$&#123;source_branch&#125;</span>&quot;</span><br>  <span class="hljs-keyword">fi</span><br><br>  <span class="hljs-keyword">if</span> [[ ! -z <span class="hljs-variable">$&#123;level&#125;</span> ]]; <span class="hljs-keyword">then</span><br>    <span class="hljs-comment"># PART 2: Create src-tag and push back</span><br>    current_version=$(node -e <span class="hljs-string">&quot;console.log(require(&#x27;./package.json&#x27;).version)&quot;</span>) &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Current version - <span class="hljs-variable">$&#123;current_version&#125;</span>&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Crated version on branch: <span class="hljs-variable">$&#123;BITBUCKET_BRANCH&#125;</span>. Tag: <span class="hljs-variable">$&#123;current_version&#125;</span>&quot;</span><br><br>    next_version=$(npx semver <span class="hljs-variable">$&#123;current_version&#125;</span> -i <span class="hljs-variable">$&#123;level&#125;</span>)<br>    source_tag=v<span class="hljs-variable">$&#123;next_version&#125;</span>-src<br><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Build source tag: <span class="hljs-variable">$&#123;source_tag&#125;</span> on branch: <span class="hljs-variable">$&#123;BITBUCKET_BRANCH&#125;</span>&quot;</span><br>    <span class="hljs-comment"># Create the source tag and push back</span><br>    npm version <span class="hljs-variable">$&#123;next_version&#125;</span> --no-git-tag-version <span class="hljs-comment"># This will not create a git tag just update the version in the package.json</span><br><br>    git add --all<br>    git commit -m <span class="hljs-string">&quot;[skip ci] <span class="hljs-variable">$&#123;current_version&#125;</span> --&gt; <span class="hljs-variable">$&#123;next_version&#125;</span>&quot;</span> <span class="hljs-comment"># [skip ci] Will not trigger this pipeline again</span><br>    git tag -am <span class="hljs-string">&quot;[skip ci] source tag: <span class="hljs-variable">$&#123;source_tag&#125;</span>&quot;</span> <span class="hljs-variable">$&#123;source_tag&#125;</span><br>    git push origin <span class="hljs-variable">$&#123;BITBUCKET_BRANCH&#125;</span> <span class="hljs-variable">$&#123;source_tag&#125;</span><br><br>    <span class="hljs-comment"># PART 3: Add the dist folder and create release tag</span><br>    <span class="hljs-comment"># Add the dist folder</span><br>    sed -i <span class="hljs-string">&#x27;s/dist//g&#x27;</span> .gitignore<br><br>    <span class="hljs-comment"># build ts</span><br>    npm run build<br><br>    <span class="hljs-comment"># push to tag</span><br>    git add --all<br>    git commit -m <span class="hljs-string">&quot;[skip ci] Build release tag: <span class="hljs-variable">$&#123;next_version&#125;</span> on branch: <span class="hljs-variable">$&#123;BITBUCKET_BRANCH&#125;</span>&quot;</span><br>    git tag -am <span class="hljs-string">&quot;[skip ci] release tag: <span class="hljs-variable">$&#123;next_version&#125;</span>&quot;</span> <span class="hljs-variable">$&#123;next_version&#125;</span> <span class="hljs-comment"># only push the tag</span><br>    git push origin refs/tags/<span class="hljs-variable">$&#123;next_version&#125;</span><br>  <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><div class="note note-info">            <p>Shell 脚本最好放在 Deployment 中执行。因为 Deployment 是阻塞队列，可以保证同一时间只有一个脚本在运行，从而避免 tag 重复冲突的问题。</p><p>同时对于开发分支的命名也需要做一定的限制。比如可以使用 husky 等工具。</p>          </div><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>这一套 Git flow 可以在任何的代码托管工具使用，即便没有类似 Pipeline&#x2F;GitAction 的触发方式同样也可以通过跑脚本的方式实现。同时可以实现自动打 tag 的功能。</p><p>虽然没有完美的 Git flow，但一套合适的 Git flow 也可以让我们的工作更加规范，提高工作的效率。</p>]]></content>
    
    
    <categories>
      
      <category>程序学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>npm</tag>
      
      <tag>git</tag>
      
      <tag>nodejs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo 多语言站点改造</title>
    <link href="/2024/01/17/2024/update-hexo-i18n/"/>
    <url>/2024/01/17/2024/update-hexo-i18n/</url>
    
    <content type="html"><![CDATA[<p>工作中搜索和查阅的文档以英文居多，于是便想着也改造一下自己博客。支持多语言的同时，顺便也算是给新的一年开一个头。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>这次改造的目标有两个：</p><ol><li>全局多语言（中-英）的支持。</li><li>不同语言之间可以互相切换。</li></ol><h2 id="探索"><a href="#探索" class="headerlink" title="探索"></a>探索</h2><p>hexo 以及之前用的 <a href="https://theme-next.js.org/">NexT</a> 主题虽然有 i18n 的支持，但都是对导航、菜单等偏固定内容的支持，并没有全局支持。</p><p>在网上搜索相关文章后，大致有如下 3 种解决方案：</p><table><thead><tr><th>序号</th><th>方案</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>1</td><td>在 <code>_post</code> 下新建 <code>en</code> 文件夹存放英文文章。</td><td>简单明了，无额外改动。</td><td>博客首页会展示所有文章。如果需要按语言显示需另外做开发。</td></tr><tr><td>2</td><td>使用 <a href="https://github.com/Jamling/hexo-generator-i18n/tree/master">hexo-generator-i18n</a> 插件。</td><td>简单，安装 + 配置即可使用。</td><td>1. 插件较长时间没有更新.<br/> 2. 安装插件后还需要另做开发，如语言切换等。</td></tr><tr><td>3</td><td>创建两套网站存放不同版本语言。</td><td>相对简单，完全独立。</td><td>两套网站部分配置和代码有冗余。</td></tr></tbody></table><p>考虑到操作和维护（主要还是懒，不想自己再开发），还是决定采用第 3 中方案。</p><p>同时在查找资料时发现了 <a href="https://hexo.fluid-dev.com/docs/">Fluid</a> 主题，感觉很舒服便趁此机会一同升级。</p><h2 id="改造"><a href="#改造" class="headerlink" title="改造"></a>改造</h2><p>在新博客的文件夹下，通过 <code>hexo init</code> 分别创建两个语言的博客。目录的结构如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">.<br>├── blog-cn<br>├── blog-en<br>└── scripts<br></code></pre></td></tr></table></figure><p>针对 Fluid 主题和多语言的配置可以参考：<a href="https://www.brando.dev/zh-hans/2021/01/03/%E8%AE%B0%E4%B8%80%E6%AC%A1-Hexo-%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E4%B8%8E%E5%A4%9A%E8%AF%AD%E8%A8%80%E7%AB%99%E7%82%B9%E6%94%B9%E9%80%A0/">记一次 Hexo 博客迁移与多语言站点改造</a>。写的十分详细，按部就班即可。</p><p>针对部署部分，参考：<a href="https://tstrs.me/1448.html">Hexo添加多语言支持「国际化i18n」</a>。将部署流程汇总到了 <code>shell</code> 文件中，阅读起来可以稍微轻松一些，也方便部署。</p><p>其本质就是在编译后的文件中多了一个 <code>en</code> 文件夹，存放英文内容。因此可以通过 <code>https://&#123;your-blog&#125;/en</code> 来访问。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Build CN blog</span><br>cd blog-cn &amp;&amp; pnpm run build<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Build En blog</span><br>cd ../blog-en &amp;&amp; pnpm run build<br><br>cd ../blog-cn<br>mkdir ./public/en &amp;&amp;mv ../blog-en/public/* ./public/en/<br><br>pnpm run deploy<br></code></pre></td></tr></table></figure><h2 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h2><p>hexo 的迁移一项是最轻松的事情。将 <code>source</code> 下需要的文件复制到新的地方即可。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>剩下的就只是翻译工作了，看看是否可以借助 Google 翻译或者 GPT 的力量了。</p><p>最后欢迎来我更新过的<a href="https://konata9.github.io/">博客</a>玩耍。</p>]]></content>
    
    
    <categories>
      
      <category>程序学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>i18n</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2023 年的 iPad 能否进行开发？</title>
    <link href="/2023/11/14/2023/2023%E5%B9%B4%E7%9A%84iPad%E8%83%BD%E5%90%A6%E8%BF%9B%E8%A1%8C%E5%BC%80%E5%8F%91/"/>
    <url>/2023/11/14/2023/2023%E5%B9%B4%E7%9A%84iPad%E8%83%BD%E5%90%A6%E8%BF%9B%E8%A1%8C%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/2023/programming.jpeg"></p><p>作为一名程序员，我们总是寻找更灵活的方式来进行开发。有一天，我突发奇想：2023年 的 iPad 能否进行开发呢？毕竟连广告也都是 “你的下一台电脑又何必是电脑”。带着这个想法，我开始了一段兴奋且艰难地探索之旅。</p><p>对于开发环境我认为只要满足以下条件即可成立：</p><ol><li>不能是 Remote 的方式，像 VSCode Server 这类的不算。</li><li>有命令行环境，支持 git、Node.js。</li><li>编辑器方面能支持 vim 以及其插件。</li></ol><p>先说结论，可以满足简单开发，但体验上磕磕绊绊。</p><span id="more"></span><h3 id="命令行工具：iSH"><a href="#命令行工具：iSH" class="headerlink" title="命令行工具：iSH"></a>命令行工具：iSH</h3><p>命令行工具是开发环境的第一步。众所周知，iPad 上是没有 Terminal 的，因此就必须借助于 APP。一番搜索之后，最终找到了 <a href="https://ish.app/">iSH</a>。</p><p>iSH 是一个基于 Alpine Linux 的模拟环境，可以在 App Store 上免费下载到。Linux 的环境给了我们很大的发挥空间，但仍然会有以下限制：</p><ol><li>Alpine Linux 是 32 位系统，意味着不支持 64 位的软件。</li><li>iSH 在每次启动时会重置一些配置，比如安装源，需要手动将进行替换。</li></ol><p>虽然有所受限，但好在已经可以安装 <code>git</code>, <code>vim</code>, <code>curl</code> 等工具了，喜欢折腾的还可以安装 <code>zsh</code>. </p><p>装完 <code>zsh</code> 之后，看着就像电脑了。</p><h3 id="Node-环境的搭建"><a href="#Node-环境的搭建" class="headerlink" title="Node 环境的搭建"></a>Node 环境的搭建</h3><p>平时以 Node 开发为主，所以能否搭建 Node 环境对我是一条重要的标准。<code>nvm</code> 自然是首选了，尽管 Readme 上有写 Alpine Linux 上的安装事项，但我在实际的使用中并不能通过 <code>nvm</code> 来切换 Node 版本。由于是 32 位系统，想要通过 <code>nvm</code> 来安装还必须得还源（<a href="https://github.com/nvm-sh/nvm/issues/1102#issuecomment-550572252">参考这个 issue</a>)。 </p><p>好在 <code>nvm</code> 并非必需，还是可以使用系统命令来安装 Node。如此一来，也算满足了 Node 环境。 </p><h3 id="Vim-的插件安装"><a href="#Vim-的插件安装" class="headerlink" title="Vim 的插件安装"></a>Vim 的插件安装</h3><p>Vim 自然是命令行下的首选，毫无疑问 Alpine 也可以安装 Vim。那么到现在，已经满足了最基本的开发需求。但如果还想追求一下开发体验，那么自然还得对 Vim 进行插件配置，让 Vim 更接近 IDE。</p><p>包管理器可以选择 <code>Vim plug</code>。一些插件如 <code>NerdTree</code> 和代码高亮插件也能顺利安装。但如果插件需要 Node 环境，就可能会遇到问题了。比如代码补全插件 <code>Coc</code> 就依赖高版本的 Node 和 npm。尽管使用了 Node 18 的版本，但插件仍然安装失败。所以除了代码提示没有外，在外观上还是很现代了。</p><p>不过装完插件后 Vim 的操作会肉眼可见地变卡。或许 iPad 的内存还是不够吧。 </p><p><img src="/images/2023/vim-short.png" alt="类似这个效果（这个是 Mac 的）"></p><h3 id="番外："><a href="#番外：" class="headerlink" title="番外："></a>番外：</h3><p>除却使用 iSH 外，还有一个 <a href="https://apps.apple.com/us/app/code-app/id1512938504?platform=ipad">Code</a> 的 APP 可以使用。</p><p>Code 可以理解为 iPad 上的 VSCode， 提供了一个集成开发环境，具有代码编辑、调试和版本控制（内置了 git）等功能，并且还支持了多种语言。除了开发上略卡，其他功能都很完美，可以说是一步到位。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>2023 年的 iPad 可以满足简单的开发需求，但体验上还不那么尽如人意。如果愿意折腾和忍受如此的开发体验，那确实可以一试。不然在轻薄程度上，我更推荐 Air 或者 Surface。</p><p>最终在折腾完了一圈后，我还是趁着教育优惠下单了 Air。Happy coding～</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>重新认识文档的重要性</title>
    <link href="/2023/01/14/2023/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E6%96%87%E6%A1%A3%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/"/>
    <url>/2023/01/14/2023/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E6%96%87%E6%A1%A3%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>2022 年有幸完整地参与了一个物联网项目，整个项目涉及APP、服务端、硬件三端交互。我参与服务端的设计与开发。同时受制于硬件，现有的对接逻辑也没发复用只能从零开始。在诸多 buff 的加持下，这个项目煎熬了我大半年。好在同组的小伙伴们比较给力，磕磕绊绊下也算完成了第一阶段的开发。</p><p>整个项目下来，最大的收获就是让我重新认识到了文档的重要性。特别是在跨团队的项目中有着不可或缺的作用。</p><span id="more"></span><p>一般项目可以粗略的分为有设计、开发、收尾三个阶段。文档也在这三个阶段有着不同的作用。以我参与的物联网项目为例。</p><h3 id="设计阶段"><a href="#设计阶段" class="headerlink" title="设计阶段"></a>设计阶段</h3><p>首先是在项目的设计阶段。这时的文档主要作为异步沟通的工具，用来确认需求和流程。输出主要是一顺序图，架构图为主，不会涉及过多细节部分。这一阶段的文档改动会十分频繁。</p><p>因为这一次的项目相当于从零开始的全新设计，所以首先需要整理出主要的流程，比如设备的绑定、子设备的添加、设备解绑这些流程。这些流程已顺序图的形式，描绘三端交互的顺序和每一步的主要逻辑。这份文档除了面向自己组内，更主要的是让其他团队能理解主要流程设计，并且能给出相应意见。在跨团队的项目中，首先开会的时间有限，其次在会上讨论过大的议题则效率会很低。而事先通过文档进行沟通，在会上着重解决问题则会更有效率。</p><p>如果有新增的服务或者是新引入的外部服务，比如云上的三方服务，这种时候就需要架构图和 POC 的设计了。这部份的文档主要用于内部技术方向的选择。对于新的服务或者较复杂的逻辑，没有书面化的文档首先难以理清思路，其次也没法作为技术选型的依据。毕竟在引入新技术或者做出较大的变更时，总是需要团队内部的沟通和同意的。</p><h3 id="开发阶段"><a href="#开发阶段" class="headerlink" title="开发阶段"></a>开发阶段</h3><p>其次是在项目的开发阶段。这时的文档除了异步沟通的工具外，还有提供使用的功能。这个阶段的输入依赖于设计阶段的文档，会添加详细的接口定义、数据结构定义，输出为接口文档、表结构文档等较为详细的部分，用来指导开发和与其他团队对接。与其他团队对接的部分要做的比较仔细，并且这一阶段文档的细节更新会较多。</p><p>此时可能会有负责开发的同事参与进来，先前设计文档可以帮助他们快速了解项目背景和自己负责的部分。如果设计文档没有做好，在这一阶段会花费较多的时间在项目沟通上，不仅会影响接口文档的质量，甚至会产生影响进度的副作用。</p><p>服务端的接口文档，不仅和开发有关更是需要提供给其他调用者参考。因此对于接口参数的定义、传入和返回的数据格式最好能有详细的定义。对于涉及到加解密算法的部分，最好能给出一个例子。而在这次的项目中，因为文档参数定义得不够严谨，花费了大量的时间在统一参数上。尽管越是详细的文档，越是花费时间，但是相比起后期因为理解偏差花费在沟通上的时间还是值得的。</p><h3 id="收尾阶段"><a href="#收尾阶段" class="headerlink" title="收尾阶段"></a>收尾阶段</h3><p>最后是在项目的收尾阶段。这时的文档主要作为项目成果的总结和展示，一般作为 Sharing 和 KPI 的资料，同时也可以帮助其他人了解项目的作用。作为后续维护和开发的基础。这个阶段的文档这一阶段的文档都是之前两阶段的文档经过修订后的文档，新的文档基本很少。</p><p>往往在这个阶段 QA 的同事会介入项目。负责 API 测试的 QA 同事就会参考之前的接口文档编写测试用例同时也会根据设计文档了解实现上的细节部分。如果前两个文档编写质量不高的话，同样也会花费很多时间在沟通和解释上。</p><h3 id="总结与思考"><a href="#总结与思考" class="headerlink" title="总结与思考"></a>总结与思考</h3><p>文档其实和代码一样，同样有着生命周期，文档的内容也是需要更新和迭代的。一份高质量的文档，不仅是自身专业性的体现，同时也可以降低沟通的成本，对开发也有着帮助。在习惯了公司设计 review 之后再开发的流程之后，整个 coding 的过程反而变得更轻松。过去 coding 到一半才会发现遗漏的次数也减少了。对我来说，写文档有利的面更多。</p><p>但文档的迭代和同步也的确是一件让人很烦恼的事情。一份文档和实际代码偏差太大变成“死”文档是很可惜的事。目前公司的文档基本都是集中在 Confluence 上（Confluence 对于 markdown 的支持并不是太好），但代码修改后文档的同步有仍然会是一件麻烦的事情。短时间的改动会让人厌烦，长时间又容易遗漏从而造成文档与代码偏差也是不愿意看到的。如果没有合适文档编写工具或者载体，这个问题相信仍然会困扰我们。</p>]]></content>
    
    
    <categories>
      
      <category>软件设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>程序员</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021 年阅读计划</title>
    <link href="/2021/01/09/2021/2021%20%E5%B9%B4%E9%98%85%E8%AF%BB%E8%AE%A1%E5%88%92/"/>
    <url>/2021/01/09/2021/2021%20%E5%B9%B4%E9%98%85%E8%AF%BB%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/2021/book-list.jpeg" alt="title"></p><p>这一年在知识技能上的规划主要以巩固补足基础为主，在集中攻克一到两个知识点的基础上进行横向展开。因此今年的阅读书单也将围绕这个目的，并且结合工作进行展开。</p><span id="more"></span><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><ol><li>Vim 实用技巧</li><li>Visual Studio Code 权威指南</li></ol><p>这两本书是配合 VSCode + Vim 来使用，主要是用来熟悉两者的快捷键和使用技巧。因为目前已经将编辑器切换为 VSCode + Vim 了，因此更多的是作为工具书，需要时查阅。</p><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><ol><li>JavaScript 高级程序设计</li><li>你不知道的 JavaScript（上）</li><li>JavaScript语言精髓与编程实践</li><li>深入理解 JavaScript 特性</li><li>JavaScript 设计模式</li></ol><p>这部分因为与工作相关，因此是今年阅读的重点。特别是前面三本，都是 JavaScript 中被奉为经典的书籍。今年的目标至少要读完一遍。后面两本作为前面的补充，没有强制目标。不过工作重心已经转移到服务端，所以关于浏览器的部分不会放太多精力。</p><h3 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h3><ol><li>Linux Tools Quick Tutorial</li><li>图解 HTTP</li></ol><p>这部分同样也与工作相关。特别是 Linux，与运维工作相关因此需要补充相应的知识。这一块将会是重点。随后的网络部分，一半是兴趣，一半同样也是和工作相关。网络相关的问题不仅是服务端，也是运维要管的部分。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li>程序员的英语</li><li>重构 改善既有代码的设计</li><li>计算机科学的基础</li></ol><p>这部分纯属个人兴趣，虽然还是会以计算机的书籍为主，但也会有小说之类的。</p><p>以上便是 2021 年的阅读计划。目前规划下来是 12 本书，数量是结合了往年的实际情况估算的。毕竟计划数量再多也是没有意义的，希望今年能好好完成计划。</p>]]></content>
    
    
    <categories>
      
      <category>随想杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>程序员</tag>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020年年终小结</title>
    <link href="/2020/12/03/2020/2020%E5%B9%B4%E5%B9%B4%E7%BB%88%E5%B0%8F%E7%BB%93/"/>
    <url>/2020/12/03/2020/2020%E5%B9%B4%E5%B9%B4%E7%BB%88%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/2020/year-end-summary.jpg" alt="title-bg"></p><p>转眼之间已是年末，又来到了年终小结的时候。无论这一年是魔幻还是平淡，每当做小结的时候，内心都会有一丝忐忑。当初定下的目标完成了多少？有哪些是自己偷懒了呢？这些问题，悄悄划过的时间是不会给出答案的。</p><p>或许这就是做小结的意义所在。这一次同样也会从工作、生活、学习三个方面来做小结。</p><span id="more"></span><h2 id="1-工作"><a href="#1-工作" class="headerlink" title="1.工作"></a>1.工作</h2><p>从前端转职为后端已经过去一年，除去平时服务端的工作之外，下半年还参与了 devops 的工作。这么一来，离自诩的“全干工程师”似乎又近了一步。</p><p>当然实际的 devops 工作也并非是在云服务上起个 Docker 这么简单事情。除了系统的架构、网络的管理、服务的部署之外，系统的监控、安全性、高可用性以及成本控制都是需要考虑的部分。在思考的角度上也更为谨慎，对于新的服务的部署也要从架构、安全性等更高的层面上进行考虑。这些方面也是作为开发，关心的较少的部分。Google 提出的 SRE 工程师的概念，或许更适合今后 devops 的发展。</p><p>在服务端的工作上，也独自开发了一个新的服务。作为对接国内平台的全新服务，参与了需求到服务架构以及开发工作。尽管由于这个项目加了些班，但让我在项目的管理以及代码结构上学到了不少的东西。特别是代码结构上，在架构师大佬的指导下一部分证实了我的想法，另一部份也加深了我对于如何划分服务和拆分方法的理解。不过还是得再次强调，不要以为有了 Demo 就能放心了，开撸代码前还是要先思考，先去请教大佬。直接开撸的结果往往就是“代码结构优化”。</p><h2 id="2-生活"><a href="#2-生活" class="headerlink" title="2.生活"></a>2.生活</h2><p>2020 年，对于生活上的变化无疑是最多的。最大的变化就是女友变成了老婆，自己的小家也已经装修。或许是上半年的“慢节奏”让下半年开启了加速键，装修与婚礼的筹办占据了下半年非常多的时间。</p><p>特别是装修，由于牵扯的工序多并且信息的不对称，即便前期和老婆一起在 B 站上做了功课，最后在实际的过程中也碰到了大大小小各种问题。特别是前期，几乎每个周末都要跑建材市场。这里要感谢家人，整个过程中会给出靠谱的参考意见以及时不时去工地监工。同事也要感谢老婆，整个过程中她做的功课要比我多，对设计图也比我仔细。目前已经在刷墙面了，硬装的部分也算是接近尾声了。等家具陆陆续续进去了，或许可以忽悠老婆去 B 站拍个 vlog 之类的吧。</p><h2 id="3-学习"><a href="#3-学习" class="headerlink" title="3.学习"></a>3.学习</h2><p>尽管下半年的学习时间被挤压的不少，但还是有一些产出的。</p><h3 id="1-AWS"><a href="#1-AWS" class="headerlink" title="1.AWS"></a>1.AWS</h3><p>今年最大的收获是蹭了一张 AWS SAA-C02 的证书（可以抵税哦）。</p><p>通过 AWS 的培训让我对系统架构有了一个全新的认识。如何从只有一个服务器的最基础的架构，逐步拓展成为一个安全的、高可用的复杂的架构。云服务虽然看似只需要点点鼠标，但需要使用哪些服务以及为什么需要这些服务，仍然需要经验和知识储备。推荐 B 站上<a href="https://www.bilibili.com/video/BV1fV41127vz">SAA-C02 的课程</a></p><h3 id="2-Vim"><a href="#2-Vim" class="headerlink" title="2.Vim"></a>2.Vim</h3><p>为什么会是 Vim？目的还是为了提高编码的效率。</p><p>某天突然发现，编码过程中的鼠标操作降低了我的操作效率。也由此第四次萌生了学习 Vim 的想法。前三次只是为了跟风, 这一次是为了提高编码效率以及在服务器上的文件编辑效率。学习采用了 VSCode + Vim 的方式，既能享受 VSCode 的快捷键以及代码提示，又能享受到 Vim 快捷键和指令的方便。教程也很方便，直接在 VSCode 的插件商店中搜索 Learn Vim 即可。</p><p>目前体验下来在编码过程中鼠标的使用次数确实减少了，但编码效率的提高并不明显，或许还保留这过去的使用习惯。不过习惯这种事情也只能慢慢修改了，希望某一天也能像认识的大神那样代码在指尖飞舞。</p><h3 id="3-网课"><a href="#3-网课" class="headerlink" title="3.网课"></a>3.网课</h3><p>在装修进了大半的时候，头脑一热报名了网课，谁知后面却接到了新项目的工作。所以网课的学习只能暂时搁置。好在网课可以延期，那么就放到 2021 年继续。</p><h3 id="4-公众号-博客"><a href="#4-公众号-博客" class="headerlink" title="4.公众号&#x2F;博客"></a>4.公众号&#x2F;博客</h3><p>自 10&#x2F;16 日之后公众号没有更新，博客也自 7&#x2F;31 日之后没有更新。这里首先要对关注公众号和博客的小伙伴说声抱歉。</p><p>由于装修和婚礼的筹备以及 SAA 刷题让我没时间进行更新，并且自己的小程序项目也很久没有维护。尽管时间上的紧张是客观事实，但从侧面上也反应出了我对事情规划的灵活性和做事效率的不足。人的惰性是真的很难对抗的。</p><p>不过在 2021 年公众号和博客将恢复更新，同时也会反思一下自己对于事情的安排也会增加灵活性来面对计划外的事情。</p><h2 id="4-展望与规划"><a href="#4-展望与规划" class="headerlink" title="4.展望与规划"></a>4.展望与规划</h2><p>总的来说，下半年的实际与年中的规划偏离了不少。既有客观因素存在，也有自己安排的不足与惰性作祟。如果硬要打分的话，只能勉强给个及格分。因为细究起来，我是可以挤出时间来完成更多事情的。</p><p>所以针对下一年，在宏观层面上要注重下面几点：</p><ol><li>事情规划上更加合理的安排。划分好优先级，在时间紧张的情况下能果断放弃一些事情。</li><li>沉下心，厚积薄发。吃透一两个知识点之后再进行横向拓展。优先级从上到下可以分为下面几条：<ol><li>JavaScript 的语言的学习。</li><li>Koa 服务端框架的精读。</li><li>Linux&#x2F;网络基础知识的学习。</li></ol></li><li>将学习方向与实际工作结合。当有工作需求在时我的效率会提高不少，同时也能克服一些惰性（AWS学习中的感悟）。</li></ol><p>无论这一年过得如何，2020 年已经翻篇。带着些许的遗憾以及些许期望，希望 2021 年能做得更好一点。</p>]]></content>
    
    
    <categories>
      
      <category>随想杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>程序员</tag>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序员上岸指北</title>
    <link href="/2020/07/31/2020/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B8%8A%E5%B2%B8%E6%8C%87%E5%8C%97/"/>
    <url>/2020/07/31/2020/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B8%8A%E5%B2%B8%E6%8C%87%E5%8C%97/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/2020/financial-freedom.png"></p><p>此前 28 岁拼多多程序员财务自由的新闻在朋友圈中传开。不久之后随着蚂蚁金服在两地同时上市，又是一波程序员财务自由了。似乎在这个资本寒冬中又给了同为程序员的我们一丝希望。</p><blockquote><p>苦海无涯，回头是岸</p></blockquote><p>即便工作辛苦，程序员的内心依旧是幽默的。上岸，这个在程序员之间调侃的词，有着多种含义。或是因为财务自由离开，或是厌倦了工作离开，亦或是成为了“输出”到社会的人才被迫离开……在离开之后一般会去考公务员、去国企，或是回老家开店。记得上一次看到这个词的时候，正是华为集中清理 34 岁以上员工的时候。</p><p>那么作为一个步入三十的平凡的程序员，今天也来聊聊程序员如何上岸吧。</p><span id="more"></span><h2 id="现实围城，程序员的光与影"><a href="#现实围城，程序员的光与影" class="headerlink" title="现实围城，程序员的光与影"></a>现实围城，程序员的光与影</h2><blockquote><p>城外的人想冲进去，城里的人想逃出来</p></blockquote><p>互联网与程序员，似乎被赋予了太多的光环。BAT 的崛起、TMD 的后来居上以及对钱不感兴趣的“马爸爸”，财务自由或许是人们对互联网最深刻的印象。而互联网行业的基石——程序员，则成为了高薪的代名词，一个个财务自由的神话也吸引着一波又一波对此向往的人。</p><p>越是耀眼的光环背后，阴影也愈发明显。随着第一代互联网人逐渐进入中年，猝死、996&#x2F;007、35 岁裁员也在光环的背后显现。尽管程序员们会幽默地对待这些，但发生在 2019 年的网易生病员工、华为 251 这些事件也在暗中提示着现实。</p><p>头顶上有着希望和理想，而脚下却又有着深渊。而作为身处围城之中的平凡的大多数，又该如何规划和打算呢？</p><h2 id="博古通今，互联网的历史"><a href="#博古通今，互联网的历史" class="headerlink" title="博古通今，互联网的历史"></a>博古通今，互联网的历史</h2><blockquote><p>以史为鉴，可以知兴替</p></blockquote><p>还是先来梳理一下国内互联网的发展史，从历史中或许能找到答案。</p><ul><li>1994 年中国正式接入互联网，开始进入开荒时代。</li><li>1997-2000，互联网的第一次爆发，现今的大厂诞生（BAT，京东、新浪、网易），而后随即进入第一次寒冬（网游也是此时诞生）。</li><li>2009 智能机的出现以及 4G 网络的完善，让用户从 PC 转移到了移动端。因此互联网第二次爆发，这一次的爆发让给我们的生活带来很多变化。团购、打车、电影这类的团购优惠服务诞生。</li><li>2019 年之后，随着用户的饱和，互联网再次进入第二次寒冬。美团大佬王兴预言：2019可能会是过去10年最差的一年，但却是未来10年最好的一年。</li></ul><blockquote><p>“从事什么职业啊”<br>“程序编程和软件开发”<br>“那就是无业”</p></blockquote><p>乱世出英雄，我们如今熟知的互联网大厂都诞生于两次爆发。早期的互联网是蛮荒之地，门户、垂直各个领域都是机会。如今的这些企业的成就，也算是当年开垦付出的回报。</p><p>与时代对应的，当时的程序员也同样没有如今这般光环，甚至如《乘风破浪》中与无业划上等号。在这个没有前人踏足过的领域，没有规范、没有门槛，也因此是真的没有任何门槛，也没有现在这样的分工。</p><blockquote><p>过去过去，未来未来</p></blockquote><p>回到当下，经历 20 多年发展的互联网行业已初步成熟，大厂的崛起也吸引着无数人才来到互联网。人多了之后，岗位便出现了竞争，行业规则与门槛也随之应运而生。早年互联网不看学历的说法，现在已逐渐成为历史。院校、专业、学历都是现今互联网不明说的标准之一。</p><p>行业成熟的另一方面也意味着收入阶梯的形成。我身边有的小伙伴在去年和今年换工作时，都遇到了提供流水这一步，这意味着互联网换一次工作收入翻一番的神话也即将终结。爆发之后冷静下来的资本，会将行业的薪资慢慢回复到一个相对合理的水平。</p><p>与此同时，入行门槛也在逐渐提高，当年只需要会切图的的前端岗如今也必须要掌握 JavaScript 的原理。更有如头条，无论什么岗位都要会点算法。LeetCode 的流行，如开课吧、网易云课堂等专门向培训班的出现，也从另一方面印证着互联网门槛的提高。有些课程主打的学完月入多少、年薪多少其实也透露着行业薪资的标准。</p><h2 id="上岸指北，选择大于努力"><a href="#上岸指北，选择大于努力" class="headerlink" title="上岸指北，选择大于努力"></a>上岸指北，选择大于努力</h2><p>华为集中清理 34 以上岁员工是在 2017 年。自此之后，35 岁危机这一概念开始出现。结合互联网的历史可以知道，2000 年投入到互联网的应届生到 2017 年，正是步入中年的年纪。而若是没有在两次爆发中翻身或是上岸，再借着中国庞大的年轻人数量，那么则极有可能成为被“清理”的对象。而这一旦开始，便再也无法停下。</p><p>那些错过或是没有抓住爆发机遇的程序员们又该如何打算呢？坐以待毙是自然不可能的，作为转行过来且步入而立之年的其中一员，我思考了下面的指北路线。上岸的也并非是一定要离开编程，也可以是向着更高的山峰前进。</p><h3 id="1-突破自己，成为那-20-的佼佼者"><a href="#1-突破自己，成为那-20-的佼佼者" class="headerlink" title="1. 突破自己，成为那 20% 的佼佼者"></a>1. 突破自己，成为那 20% 的佼佼者</h3><p>技术真的有年龄界限么？那些我们熟知的程序界的大神如 Linus、Ryan Dahl 都早已过了被“清退”的年纪，但过硬的技术实力让他们可以常驻在神坛。</p><p>技术是编程的基础，也是各个公司看重的硬实力。像这些编程界的大神看齐，努力提升自己的硬实力是最直接也是最艰苦的一条路。要成为大神级别的人物就要如同当年的高考一样，成为那 20% 的佼佼者。无论是钻研技术成为架构师还是转型成为管理者，变得优秀都能延长自己的职业寿命。</p><p>不要忘了，经过 20 多年的发展，国内互联网也诞生了无数大神。尽管相较国外的大神要年轻许多，但其实也到了步入中年的时候。那些大厂真的会忍心将这些大神“输出”到社会吗？我们可以拭目以待。</p><h3 id="2-转攻为守，提升自己的软技能"><a href="#2-转攻为守，提升自己的软技能" class="headerlink" title="2. 转攻为守，提升自己的软技能"></a>2. 转攻为守，提升自己的软技能</h3><p>通往罗马的路不止一条。除了专攻技术提升自己，我们还可以做好防守。</p><p>自媒体以及知识付费，与程序员非常契合。由于工作的关系，程序员本身就掌握着技术，结合着入行门槛的提升，把这些技术作为知识输出则自然地与自媒体和知识付费结合上了。一旦自身品牌建立起来之后，就能将流量转为收入，从而为自己筑起一道防线。阮一峰老师就是一个很好的学习榜样。</p><p>尽管自媒体的爆发时期已过，但人们对于内容的需求和知识的渴望是始终存在的。自建博客、掘金社区、微信公众号都是不错选择，只是在内容上需要下更多的功夫。</p><p>除此之外，适当的理财和投资也都是不错的选择。这部分并不是我的强项，因此推荐《软技能》这本书。比起那些技术书籍，这本书或许在入行之前就应该先去看一看。</p><h3 id="3-脱离苦海，回头上岸"><a href="#3-脱离苦海，回头上岸" class="headerlink" title="3. 脱离苦海，回头上岸"></a>3. 脱离苦海，回头上岸</h3><p>这条路或许是最后的选择。滴滴与外面行业的兴起，拓宽了原本公务员和保险行业以及创业的选项。只不过这看起来像是从一个围城跳到另一个围城。毕竟离开自己熟悉的领域，是非常花费成本的一件事。</p><p>在互联网发展的背后，仍有不少传统行业缺乏互联网方面的人才。选择传统行业，把互联网引入进去也是可以考虑的方向。</p><h3 id="送给年轻的小伙伴"><a href="#送给年轻的小伙伴" class="headerlink" title="送给年轻的小伙伴"></a>送给年轻的小伙伴</h3><p>对于年轻（28 岁以下）的小伙伴来说，上面的这些规划是暂时用不上的。你们要做的就是努力进入大厂，拥有一段大厂的工作背景，然后不要被大厂的薪资迷惑，尽可能地节约做好理财即可。</p><p>为何要强调大厂，从大环境上来说，大厂实力雄厚不太会因为大环境的变动而产生剧变。从个人发展来说大厂的经验与学历一样，无论今后是否还在互联网都会是一个亮点。其次大厂有完整的技术规范和体系，最关键的是有体量的业务场景。特别是业务场景，这是其他小厂几乎没有的。最后大厂拥有相对公平的薪资体系与晋升通道。</p><p>同样的，也不要被那些负面新闻所影响，大厂正是因为体量大才会出现各种事情。不要刻意放大这些负面信息，大厂体制的完善程度是许多小厂没法比较的。</p><p>与之对比小厂更像是一场赌博。成功就会一朝翻身，而失败的话则是青春蹉跎。</p><p>而尽可能地节约和做好理财，则是为自己留下后路。程序员初期较高的薪资，很容易积累起资金。而上面所写的上岸规划，都有一个前提条件，那就是有资金储备。只有有了足够的资金储备，将来无论是进是退都会胸有成竹。</p><h2 id="美好愿景，寻回自己的初心"><a href="#美好愿景，寻回自己的初心" class="headerlink" title="美好愿景，寻回自己的初心"></a>美好愿景，寻回自己的初心</h2><blockquote><p>你选择了前端，他选择了后端，无论是否上岸，你们都会有美好的未来</p></blockquote><p>写到这一节的时候，不禁回想起自己对于编程的初心。</p><p>虽说在大学时的大作业让我喜欢上了前端，进而喜欢上了编程，但或许热爱的种子早在初中买下 RPG Maker 的时候就已经种下了。独立作出一款游戏，仍是我现在的梦想。特别是在 B 站看到了全能型的游戏制作者 A大(AliveGameStudio) 之后。</p><p>初心有时是一种力量，在疲惫的时候，看源码看得心烦意乱的时候，回忆起自己的初心能让内心重回平静。当被工作和生活压的喘不过气时，不妨回忆下自己的初心。</p><p>愿所有在这一行奋斗的小伙伴，最后都能实现自己的理想。完成真正的上岸。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/27368394">中国互联网发展简史（1994-2017年）</a></li><li><a href="https://github.com/evil-huawei/evil-huawei">Evil Huawei - 华为作过的恶</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>随想杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>程序员</tag>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>整理自己的知识图谱</title>
    <link href="/2020/07/12/2020/%E6%95%B4%E7%90%86%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    <url>/2020/07/12/2020/%E6%95%B4%E7%90%86%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/2020/mindmap.png"></p><h2 id="为什么要整理知识图谱"><a href="#为什么要整理知识图谱" class="headerlink" title="为什么要整理知识图谱"></a>为什么要整理知识图谱</h2><blockquote><p>大音希声，大象无形，大道至简</p></blockquote><p>自从步入 Coding 的世界之后，几乎每天都有新的知识出现。特别是在做前端的时候，新框架、新类库更是层出不穷。即便跟着指引走完教程，在实际上手时仍会有一些手足无措。其原因可能是没有与已有的知识产生联系。</p><span id="more"></span><p>回顾学生时代，我们在学习新知识的时候都是从点入手，形成一个个知识点，然后再将知识点连接起来形成一张知识网络。而网络的疏密最终会反映在我们的成绩上。这个道理放回 Coding 中也是一样的。</p><p>随着 Coding 小时数的上升，当项目经验丰富后，往往就会进入瓶颈期。此时，组织起一个属于自己的知识图谱无疑会对突破瓶颈提升自己带来帮助。每当对自己的知识充满信心时，不妨回顾一下那道经典的面试题，来检验一下图谱中是否还有欠缺的地方。</p><p><em>输入url到加载完页面发生了什么？</em></p><h2 id="我的知识图谱"><a href="#我的知识图谱" class="headerlink" title="我的知识图谱"></a>我的知识图谱</h2><p>作为 2020 年下半年最主要的学习计划便是整理出属于我自己的知识图谱。将目前掌握的、工作中遇到和涉及的知识做一个汇总和串联。结合自身的情况，我将自己的知识分为前端、服务端、计算机基础、devOps、代码管理以及软技能 5 部分。</p><p><img src="/images/2020/mindmap-simple.png"></p><p>从每部分知识点的细分程度就能很明显地发现自己擅长与不擅长的地方（虽然当中还包含了一些只是知道但并没有掌握的知识）。</p><p>结合这份知识图谱，下半年给自己订的目标主要有两个。</p><ol><li><p>加强服务端的知识</p><p> 一是因为现在的主要工作是服务端开发，二是我的技术栈都围绕 JavaScript，因此在补足服务端知识的同时对前端知识的强化也有帮助。现在的计划是从 Koa 源码开始（已经通读一遍，计划写系列分享文章）。</p></li><li><p>补充计算机基础知识</p><p> 计算机基础是 Coding 的内功。作为非 CS 专业出身，内功本身就有所欠缺。并且随着 Coding 门槛的逐步提高，打好算法、数据结构的基础已是必然的趋势。</p></li></ol><p>最后，年底的时候打算尝试着回答一下 <em>输入url到加载完页面发生了什么？</em> 作为下半年的检验。</p><h2 id="知识图谱需要量身定制"><a href="#知识图谱需要量身定制" class="headerlink" title="知识图谱需要量身定制"></a>知识图谱需要量身定制</h2><blockquote><p>世界上没有两片相同的树叶</p></blockquote><p>每个人掌握的知识以及方向各异，因此每个人的知识图谱也不尽相同。</p><p>知识图谱的建立并非要做到各个方面都要精通。在构建完成后，就能对目前自己的长项短项有所了解。在查漏补缺的过程中也能有的放矢。</p><p>毕竟人的精力是有限的，工作和学习之外还有生活要过。那么在有限的精力中，利用知识图谱是将自己的长处发挥到最大，还是弥补自己的短处这又是另一个话题了。</p>]]></content>
    
    
    <categories>
      
      <category>程序学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>程序员</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React 一瞥</title>
    <link href="/2020/06/21/2020/React%20%E4%B8%80%E7%9E%A5/"/>
    <url>/2020/06/21/2020/React%20%E4%B8%80%E7%9E%A5/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/2020/react-glance.png"></p><p>最近使用 React 重构了一个内部管理工具的前端界面。在等待 PM 试用提需求的间隙，接到了一个给后端小伙伴科普 React 的任务，便有了本文。本文将从 DOM 以及早期的 Web 开发入手，期望让没有接触过前端开发或者没有 React 经验的后端同学，对 React 有一个入门的认识与兴趣。而对于前端经验丰富的小伙伴，也期望本文能是你们拉后端入坑的文章之一。</p><h2 id="0-什么是-DOM-？"><a href="#0-什么是-DOM-？" class="headerlink" title="0. 什么是 DOM ？"></a>0. 什么是 DOM ？</h2><p><strong>DOM</strong> 全称 Document Object Model，即文档对象模型，是前端开发中最重要的概念之一。网页由一个个 HTML 标签组成，而 DOM 则提供了访问和操作 HTML 的标准方法。利用 DOM 提供的 API，我们就能使用 JavaScript 对页面进行各种操作。</p><span id="more"></span><h2 id="1-石器时代"><a href="#1-石器时代" class="headerlink" title="1. 石器时代"></a>1. 石器时代</h2><p>可以思考一下，如果我们把百度的搜索按钮从蓝色换成红色，需要怎么做呢？（不用考虑 API，只考虑思路）</p><p><img src="/2020/baidu-html.png" alt="image-20200621120404685"></p><p>只需两步即可：</p><ol><li>找到搜索按钮的 HTML 元素</li><li>利用 DOM 提供的 API 把蓝色改成红色</li></ol><p>是的，这就是最基础的编辑 HTML 的操作。早期的 Web 开发（jQuery 时代）就是这样的一个面向过程的开发，我们通过直接操作一个个 HTML 元素来实现各种效果。然而随着 Ajax 的出现、Gmail 带来 Web 富应用的可能性以及 V8 的出现，Web 的功能也变得越来越复杂和强大。面向过程冗长且难以维护的缺点开始越发明显。</p><h2 id="2-为什么不偷懒呢-？"><a href="#2-为什么不偷懒呢-？" class="headerlink" title="2. 为什么不偷懒呢 ？"></a>2. 为什么不偷懒呢 ？</h2><p>开发过程变得复杂之后，便激发了人们想要偷懒的潜力。把上面的第二步再做一次拆分，整个步骤就分为：</p><ol><li>找到需要修改的目标 HTML 元素</li><li>计算出更新后的数据</li><li>把新的数据更新到目标 HTML 元素</li></ol><p>在 Web 开发中，UI 的变化与数据的变化是强相关的，DOM 的操作又是相对固定的（主要给 DOM 做一些增删改查的操作）。</p><p>既然数据可以决定 UI，如果有一种类库或框架能让我们只关心数据变化而不用管理 DOM 操作，那我们的开发过程岂不是能轻松很多？</p><h2 id="3-React-登场"><a href="#3-React-登场" class="headerlink" title="3. React 登场"></a>3. React 登场</h2><p><a href="https://reactjs.org/">React</a> 由 Facebook 开发，于 2013 年的 JSConf 上开源。React 的底层帮我们实现了更新 HTML 的操作，让我们把注意力都集中在数据的操作和管理上。从很大程度上减轻了前端开发的工作量，所以一经面世便受到了巨大的反响。目前国内外大厂，都会使用 React 作为自己的前端技术栈之一。</p><p>React 的概念比较多，因此上手之前需要了解一些重要的概念。</p><h3 id="数据驱动，数据驱动，数据驱动"><a href="#数据驱动，数据驱动，数据驱动" class="headerlink" title="数据驱动，数据驱动，数据驱动"></a>数据驱动，数据驱动，数据驱动</h3><p>重要的事情说三遍。比起 React 的语法概念，<strong>数据驱动</strong>的思想更为重要。前端开发由于有 UI 设计的存在，思维容易过程化。从 jQuery 转过来的小伙伴（包括我自己）刚开始会觉得 React 有点 ”反直觉“，对于页面的操控不直观。这一点在做拖拽等功能时特别明显。</p><p>但是 React 中的 UI 都是由数据来决定，数据怎么变化 UI 就怎么变化。在操作 DOM 之前，先思考一下数据是怎么变化的。</p><h3 id="JSX、组件、生命周期、State-Props"><a href="#JSX、组件、生命周期、State-Props" class="headerlink" title="JSX、组件、生命周期、State&#x2F;Props"></a>JSX、组件、生命周期、State&#x2F;Props</h3><h4 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h4><blockquote><p>JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式。JSX 可能会使人联想到模版语言，但它具有 JavaScript 的全部功能。</p></blockquote><p>JSX 是一个语法糖，可与允许我们在 JavaScript 中使用 HTML 的语法形式来编写与页面相关的内容。比如 HTML 标签、属性，CSS 相关属性以及自定义的 React 组件。对于习惯了 HTML 的前端开发者来说，这无疑降低了学习成本。这也为 <code>all-in-JS</code> 打下了基础。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// in HTML</span><br>&lt;div id=<span class="hljs-string">&quot;a&quot;</span>&gt;<span class="hljs-number">1234</span>&lt;<span class="hljs-regexp">/div&gt; /</span>/ <span class="hljs-title class_">Only</span> accept html<br><br><span class="hljs-comment">// in JSX</span><br>&lt;div id=<span class="hljs-string">&quot;a&quot;</span>&gt;<span class="hljs-number">1234</span>&lt;/div&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">CustomComponent</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;custom&quot;</span> /&gt;</span></span> <span class="hljs-comment">// Also accept custom component</span><br></code></pre></td></tr></table></figure><h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><blockquote><p>组件允许你将 UI 拆分为独立可复用的代码片段，并对每个片段进行独立构思。</p></blockquote><p>组件是组成页面单元，其中功能最单一、划分维度最小的称为原子组件（比如 input, button）。通过不同组件的组合与嵌套，可以实现不同功能页面部分，如同化学中分子可以组成不同的物质。下面是掘金首页的组件划分（没有到原子层级）：</p><p><img src="/images/2020/component-example.png" alt="image-20200621170620546"></p><p>通过组件可以让代码得到复用，减少开发工作量。最大好处是便于后期维护的，组件可以单独替换来满足不同需求，同时也不用担心影响其他功能。尽管组件在形式上与我们常用的 <code>util</code> 方法类似，但如何划分页面，规划好组件是需要在动手之前就要好好思考的。</p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p><img src="/images/2020/react-lifecycle.jpg"></p><p>只看这张图恐怕很难记住 React 的生命周期，其实回想一下 React 帮我们做了什么就会变得容易一些。React 帮我们实现了 DOM 的更新，让我们只需要关注数据即可。那么 DOM 要什么时候才会更新呢？</p><ol><li>页面初次渲染 （componentWillMount –&gt; componentDidMount –&gt; render –&gt; componentWillUnmount)</li><li>页面内有数据发生变动 (componentWillUpdate –&gt; render –&gt; componentDidUpdate)</li></ol><p>React 的生命周期就是在这两个的时间点上的拓展，特别是对于数据发生变动时的拓展（Update部分）。也意味着我们在组件的某一个时间点能做哪些，一般情况下，主要关注 <code>componentDidMount</code> 和 <code>componentWillUnmount</code> 这两个生命周期即可。</p><h4 id="State-Props"><a href="#State-Props" class="headerlink" title="State&#x2F;Props"></a>State&#x2F;Props</h4><p>React 的特点就是数据发生变化时会更新 UI。而这些可以出发 UI 更新的数据在 React 中分为 <code>state</code> 和 <code>props</code>。</p><p>两者之前的区别就是 <code>props</code> 是传入组件的数据，<code>state</code> 是组件内部数据。类比函数 <code>props</code> 是传入的参数，而 <code>state</code> 是函数内部自己的变量。组件的刷新可以类比为改变入参和内部参数后函数的重新调用。 </p><p>对于 <code>props</code> 来说，只要值发生变化，那么组件自然就会更新。而对于 <code>state</code> 来说，React 提供了 <code>setState</code> 方法让我们更新组件内部的状态。</p><p>对于拥有 <code>state</code> 的组件，一般称为状态组件通常会使用 class 的形式。而没有 <code>state</code> 的组件一般称作无状态组件，可以直接写成 <code>function</code> 的形式。这两种都是 React 组件的写法。</p><h2 id="4-一如即往的-Todo-List"><a href="#4-一如即往的-Todo-List" class="headerlink" title="4. 一如即往的 Todo List"></a>4. 一如即往的 <code>Todo List</code></h2><p>光说不练，是没有意义的。所以我们会用一个经典的 <code>Todo List</code> 来作为例子。作为入门示例，这里不会引入过多概念，只会用到上面所提到的概念。</p><p>代码地址：<a href="https://codesandbox.io/s/todo-list-example-of-react-wohr2?file=/src/App.js">CodeSandbox</a></p><p><img src="/2020/todo-example.png" alt="image-20200621195718366"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./styles.css&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-comment">// 初始化组件用到的 state</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>      <span class="hljs-attr">todoList</span>: [], <span class="hljs-comment">// Todo List 列表</span><br>      <span class="hljs-attr">todoName</span>: <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment">// 储存输入框的内容</span><br>    &#125;;<br><br>    <span class="hljs-comment">// 使用 function 时需要注意 this 的绑定，这里涉及 JS 中 this 的指向</span><br>    <span class="hljs-comment">// 在本例子中不作展开</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">setTodo</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">setTodo</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">addTodoList</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">addTodoList</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">setTodoStatus</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">setTodoStatus</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">deleteTodo</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">deleteTodo</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">setTodo</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-comment">// 更新输入框的内容</span><br>    <span class="hljs-comment">// 只有更新了 setState 才会同步反应到 HTML</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>      <span class="hljs-attr">todoName</span>: e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span><br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-title function_">addTodoList</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123; todoList, todoName &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>;<br>    todoName &amp;&amp;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>        <span class="hljs-comment">// 更新数组时注意 JavaScript 引用类型的操作</span><br>        <span class="hljs-attr">todoList</span>: [...todoList, &#123; <span class="hljs-attr">name</span>: todoName, <span class="hljs-attr">isDone</span>: <span class="hljs-literal">false</span> &#125;],<br>        <span class="hljs-attr">todoName</span>: <span class="hljs-string">&quot;&quot;</span><br>      &#125;);<br>  &#125;<br><br>  <span class="hljs-title function_">setTodoStatus</span>(<span class="hljs-params">index</span>) &#123;<br>    <span class="hljs-keyword">let</span> &#123; todoList &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>;<br>    <span class="hljs-keyword">const</span> target = todoList[index];<br>    target.<span class="hljs-property">isDone</span> = !target.<span class="hljs-property">isDone</span>;<br><br>    <span class="hljs-keyword">if</span> (target.<span class="hljs-property">isDone</span>) &#123;<br>      todoList.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);<br>      todoList = [...todoList, target];<br>    &#125;<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>      todoList<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-title function_">deleteTodo</span>(<span class="hljs-params">index</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123; todoList &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>;<br>    todoList.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>      todoList<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// render 中对应着 HTML 部分，这里的语法便是 JSX</span><br>    <span class="hljs-keyword">const</span> &#123; todoList, todoName &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>;<br><br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;search-bar&quot;</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;todoName&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Input your todo list&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.setTodo&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          /&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.addTodoList&#125;</span>&gt;</span>Add<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span></span><br><span class="language-xml">          &#123;todoList.map((todo, index) =&gt; &#123;</span><br><span class="language-xml">            const &#123; isDone = false, name = &quot;&quot; &#125; = todo;</span><br><span class="language-xml">            return (</span><br><span class="language-xml">              <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;todo-item&quot;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;index&#125;</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;item-content&quot;</span>&gt;</span></span><br><span class="language-xml">                  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;label&quot;</span>&gt;</span>&#123;index + 1&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">                  <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">                    <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">                    <span class="hljs-attr">checked</span>=<span class="hljs-string">&#123;isDone&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">                    <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> this.setTodoStatus(index)&#125;</span><br><span class="language-xml">                  /&gt;</span><br><span class="language-xml">                  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> this.deleteTodo(index)&#125;&gt;Delete<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">              <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">            );</span><br><span class="language-xml">          &#125;)&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span></span><br><span class="language-xml">      &lt;/div</span><br><span class="language-xml">    );</span><br><span class="language-xml">  &#125;</span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><p>短短 100 行代码，就能实现一个简单的 Todo List。虽然功能实现了，但上面的代码有许多值得改进的地方。</p><p>最大的改进点就是<strong>组件化</strong></p><p>从效果图来看，Todo List 是一个很明显的上下结构。并且上面的输入框与下面的列表并不耦合，因此可以拆分出两个独立的组件，并让组件自己管理自己的 <code>state</code>。从而实现 “组件状态的自治”。</p><p>修改之后的 <code>App.js</code> 如下，把上半部分拆分出去让输入框自己管理状态。而下半部分的列表则纯粹成了一个渲染组件，没有任何的 <code>state</code> 即无状态组件。就可以使用函数的形式再次精简。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./styles.css&quot;</span>;<br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">SearchBar</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./searchBar&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">List</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./List&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>      <span class="hljs-attr">todoList</span>: [] <span class="hljs-comment">// Todo List 列表</span><br>    &#125;;<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">addTodoList</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">addTodoList</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">setTodoStatus</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">setTodoStatus</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">deleteTodo</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">deleteTodo</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">addTodoList</span>(<span class="hljs-params">value, e</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123; todoList &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>;<br>    value &amp;&amp;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>        <span class="hljs-attr">todoList</span>: [...todoList, &#123; <span class="hljs-attr">name</span>: value, <span class="hljs-attr">isDone</span>: <span class="hljs-literal">false</span> &#125;]<br>      &#125;);<br>  &#125;<br><br>  <span class="hljs-title function_">setTodoStatus</span>(<span class="hljs-params">index</span>) &#123;<br>    <span class="hljs-keyword">let</span> &#123; todoList &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>;<br>    <span class="hljs-keyword">const</span> target = todoList[index];<br>    target.<span class="hljs-property">isDone</span> = !target.<span class="hljs-property">isDone</span>;<br><br>    <span class="hljs-keyword">if</span> (target.<span class="hljs-property">isDone</span>) &#123;<br>      todoList.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);<br>      todoList = [...todoList, target];<br>    &#125;<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>      todoList<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-title function_">deleteTodo</span>(<span class="hljs-params">index</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123; todoList &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>;<br>    todoList.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>      todoList<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123; todoList &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>;<br><br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">SearchBar</span> <span class="hljs-attr">addTodoList</span>=<span class="hljs-string">&#123;this.addTodoList&#125;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">List</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">todoList</span>=<span class="hljs-string">&#123;todoList&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">setTodoStatus</span>=<span class="hljs-string">&#123;this.setTodoStatus&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">deleteTodo</span>=<span class="hljs-string">&#123;this.deleteTodo&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5. 参考资料"></a>5. 参考资料</h2><ol><li><a href="https://zh-hans.reactjs.org/">React 官网</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>程序学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>程序员</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020年年中小结</title>
    <link href="/2020/06/09/2020/2020%E5%B9%B4%E5%B9%B4%E4%B8%AD%E5%B0%8F%E7%BB%93/"/>
    <url>/2020/06/09/2020/2020%E5%B9%B4%E5%B9%B4%E4%B8%AD%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/2020/summary.jpg" alt="title-bg"></p><p>疫情的出现让许多人的生活与以往大不相同，然而时间还是一如既往地默默前进着。”最长春节“与”超前“的在家办公之后，2020 年也来到了中点。自然也到了年中小结的时候了。</p><p>关注此方公众号的小伙伴知道，此方每半年会做一次小结。与 <a href="https://mp.weixin.qq.com/s?__biz=MzA5MjEzMjg2NA==&mid=2247485576&idx=1&sn=3e3fc056007a805fe1368733bec4a057&chksm=90708be7a70702f1ec16a2a6045c7727815b0d8f8f726e2cc510edafa6454f884d416a66f1d9&token=1803782758&lang=zh_CN#rd">2019 的自我回顾</a> 做对比，这一次也会从工作、学习、生活、公众号&#x2F;博客四个方面来做小结。</p><span id="more"></span><h2 id="1-工作"><a href="#1-工作" class="headerlink" title="1. 工作"></a>1. 工作</h2><blockquote><p>换语言是不可能换的，ES6+ 又有了新特性，个个都很好用。我超喜欢的～</p></blockquote><p>2019 年底幸运地换到了新的工作并且也没有受到疫情的影响。目前从事 Nodejs 开发，尽管从前端转到了后端，不过语言始终没变。虽然能写 Node 能搭服务器还会用一点 docker，但离真正意义上的全栈还有很长的一段路。</p><p>JavaScript 尽管在工作中已经能很顺手地使用了，但原理以及深度上还是会自觉所有不够。另外在思维上还带着前端思考问题的习惯，问题抽象的能力还有待提高。因此下半年会打算在原理和源码阅读上多花一些功夫，一是学习源码思考问题和抽象代码的方式，二是对 JavaScript 的原理部分再更近一步地学习。当然工作中也会学习身边优秀同事的工作习惯与思考方式，要多向现在组里的架构师大神取经。</p><h2 id="2-学习"><a href="#2-学习" class="headerlink" title="2. 学习"></a>2. 学习</h2><h3 id="GitHub-记录"><a href="#GitHub-记录" class="headerlink" title="GitHub 记录"></a>GitHub 记录</h3><p><img src="/images/2020/github-summary.png" alt="github-summary"></p><p>程序员的学习离不开代码，所以 GitHub 的提交记录最能说明问题。除去 3 月有些偷懒外，上半年的提交情况自我还是比较满意的。下半年也要继续保持下去。 </p><h3 id="LeetCode-记录"><a href="#LeetCode-记录" class="headerlink" title="LeetCode 记录"></a>LeetCode 记录</h3><p><img src="/images/2020/leetcode-summary.png" alt="image-20200609213332659"></p><p>从 5 月开始做起了算法，这一次不是为了刷题只是为了挑战一下自己。大学时期被算法支配的恐怖以及之前面试微软时直接被算法打趴下的无力感都历历在目。现在保持一天或者两天的速度慢慢前进。作为算法渣，有些题确实让人掉头发。</p><p>另外在学习的过程中发现，之前的工作中更多的是一个 “工具人” 的角色，能写代码能跑程序而已。尽管会用，但在一些基础的知识上却经不起推敲。这也说明了自己 “内功” 的不足。编程是外功，而计算机科学的基础知识是内功。内功练扎实了，问题也就能深挖下去了。因此下半年会抽空补一补计算机原理、网络、设计模式之类的基础知识。目前在听的是 《深入浅出计算机原理》这课。</p><h2 id="3-生活"><a href="#3-生活" class="headerlink" title="3. 生活"></a>3. 生活</h2><p>随着年龄的增长，生活也不再是工作学习两点了。即将就要组成自己的小家了，生活中的各种事情也会加入到日常中。如何平衡好生活与学习，会是接下来的一个重点。或许保证健康、保证睡眠的前提下，如何提高学习效率或许是程序员一生都要纠结的问题吧。</p><p>疫情过后，对生活和工作也有了新的认识。这些打算在之后写一篇来聊一聊我自己对国内程序员的职业的感悟。</p><h2 id="4-公众号-博客"><a href="#4-公众号-博客" class="headerlink" title="4. 公众号&#x2F;博客"></a>4. 公众号&#x2F;博客</h2><p>公众号上 “夏亚名言” 系列已经全部完结。0083 系列很想做，因为需要整理、翻译，时间上排下来需确实不够。因此今后的公众号还是以技术和生活感悟的文章为主。公众号上也有问我关于学程序以及对日 IT 经验的小伙伴，这一块或许整理成文章会比较好。博客也会同步更新。</p><p>小程序的服务器也继续续了一年。一直想着的重构现在还继续坑着……不过如果真做了 0083 那就必须要重构了……</p><hr><p>2020 年的上半年就这么过去了，尽管节奏被疫情影响，但生活还要继续。希望年终总结时，能取得一个自己满意的成绩吧～</p><p><img src="/images/2020/kizunaai-btm.png"></p>]]></content>
    
    
    <categories>
      
      <category>随想杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>程序员</tag>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 VSCode 远程调试 Node.js</title>
    <link href="/2020/03/21/2020/%E4%BD%BF%E7%94%A8%20VSCode%20%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%20Node.js/"/>
    <url>/2020/03/21/2020/%E4%BD%BF%E7%94%A8%20VSCode%20%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%20Node.js/</url>
    
    <content type="html"><![CDATA[<p>通常在 VSCode 中调试 Node.js 只需要按下 <code>F5</code> 或是使用调试面板。这种方式对于调试本地代码非常方便，特别是对于脚本类的调试。不过实际工作中，开发代码往往部署在服务器上，如果想在本地调试的话就意味着本地也需要一套相同的环境。为了避免这种情况，就需要用到远程调试了。</p><span id="more"></span><h3 id="配置-launch-json"><a href="#配置-launch-json" class="headerlink" title="配置 launch.json"></a>配置 launch.json</h3><p>Node.js 中包含的 Debug 模块支持远程调试。我们需要做的就是在 VSCode 中做好对应的配置就行。</p><p>VSCode 关于代码调试的配置都通过 <code>launch.json</code> 文件管理。我们可以通过 <code>cmd + shift + p</code> 输入 <code>launch.json</code> 打开配置，也可以通过调试面板上的设置按钮打开。</p><p><img src="/images/2020/vscode-debug.png" alt="image-20200320210225047"></p><p>VSCode 会自动提示 <code>launch.json</code> 中 的对应属性以及可选值，所以不用太担心配置。对于远程调试我们需要关注这些属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;node&quot;</span>, <span class="hljs-comment">// node 调试</span><br>  <span class="hljs-string">&quot;request&quot;</span>: <span class="hljs-string">&quot;attach&quot;</span>, <span class="hljs-comment">// launch / attach。luanch 为本地调试，attach 为远程/跨进程调试</span><br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Remote server&quot;</span>, <span class="hljs-comment">// 启动配置的名称，在面板中可以选择</span><br>  <span class="hljs-string">&quot;address&quot;</span>: <span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-comment">// 服务器地址</span><br>  <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">9229</span>, <span class="hljs-comment">// 服务器端口，默认为 9229</span><br>  <span class="hljs-string">&quot;localRoot&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/node&quot;</span>, <span class="hljs-comment">// 本地程序所在的目录</span><br>  <span class="hljs-string">&quot;remoteRoot&quot;</span>: <span class="hljs-string">&quot;/root/workspace/node&quot;</span> <span class="hljs-comment">// 服务器对应程序所在的目录</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="远程调试"><a href="#远程调试" class="headerlink" title="远程调试"></a>远程调试</h3><p>配置完成后就可以进行远程调试了，这里以我对远程服务器调试为例。在启动服务前，需要添加 <code>--inspect</code> 参数来开启 node 服务。</p><p>首先我们先启动服务器上的脚本，注意别忘记添加 <code>--inspect</code> 参数。这个脚本会每隔一秒打印 log 信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">node --inspect=0.0.0.0:9229 ./script.js<br></code></pre></td></tr></table></figure><p><img src="/images/2020/server-debug.gif"></p><p>同时在 <code>launch.json</code> 中添加服务器的配置。</p><p><img src="/images/2020/vscode-launch.png" alt="image-20200320224246780"></p><p>配置好之后，我们在 VSCode 中对代码打上断点并开启调试。</p><p><img src="/images/2020/remote-debug.gif"></p><p>在连接上远程服务器之后，VSCode 的控制台中也会同步输出 log 信息，并且会停在断点位置。此时服务器的 log 也会同时停止。这样便完成了本地与服务器上代码的同步调试。</p><h4 id="没开-debug-模式？"><a href="#没开-debug-模式？" class="headerlink" title="没开 debug 模式？"></a>没开 debug 模式？</h4><p>上面的例子里，是我们可以对服务器为所欲为的情况。但实际工作中，可能并不允许我们去重启服务。这时我们就需要传入 SIGNAL 来控制 node 开启 debug 服务了。官方允许我们传入 <code>SIGUSR1</code> 这一信号来开启 debug 模式。</p><p>在传入信号前，我们需要找到 node 服务的进程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -a | grep node<br></code></pre></td></tr></table></figure><p>通过上面的命令，我们可以找到 node 服务所在的进程，然后再通过 <code>kill -s</code> 命令把信号传过去。以我服务器为例。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kill -s SIGUSR1 <br></code></pre></td></tr></table></figure><p>可以看到在服务端的 log 中多了一段端 debug 模式开启的信息。</p><p><img src="/images/2020/signal-server.gif"></p><h4 id="端口限制？"><a href="#端口限制？" class="headerlink" title="端口限制？"></a>端口限制？</h4><p>在做完上面一步之后其实还并不能进行远程调试。原因是通过 <code>SIGUSR1</code> 开启的 debug 模式的 ip 为 <code>127.0.0.1</code> 即外网无法访问（所以在上面我们使用的是 0.0.0.0）。</p><p>这是就需要使用到端口转发了。通过 <code>ssh</code> 命令将服务器的端口转发到本地之后，就同样可以进行远程调试了。关于端口转发可以参考阮一峰老师的<a href="https://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html">文章</a>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh -L 9229:127.0.0.1:9229 root@服务器 IP<br></code></pre></td></tr></table></figure><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p><a href="https://nodejs.org/en/docs/guides/debugging-getting-started/">Node.js 官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>程序学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node.js</tag>
      
      <tag>VSCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>译:解谜 10 倍程序员神话</title>
    <link href="/2020/03/14/2020/%E8%AF%91_%E8%A7%A3%E8%B0%9C%2010%20%E5%80%8D%E7%A8%8B%E5%BA%8F%E5%91%98%E7%A5%9E%E8%AF%9D/"/>
    <url>/2020/03/14/2020/%E8%AF%91_%E8%A7%A3%E8%B0%9C%2010%20%E5%80%8D%E7%A8%8B%E5%BA%8F%E5%91%98%E7%A5%9E%E8%AF%9D/</url>
    
    <content type="html"><![CDATA[<p>“10 倍程序员” 的概念诞生于 《人月神话》一书中，在国外一度成为热议话题。所谓的 “10 倍程序员” 究竟又是怎样的呢？是否真的是一个人干十个人的活呢？</p><p>本文来自于 IT 之家，原文地址: <a href="https://payne.org/blog/the-myth-of-the-myth-of-the-10x-programmer/?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website">https://payne.org/blog/the-myth-of-the-myth-of-the-10x-programmer/?utm_source=wanqu.co&amp;utm_campaign=Wanqu+Daily&amp;utm_medium=website</a></p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>我在 DEC 的第一份工作是为 Aplha 处理器编写 “设计验证测试”。这些测试使用汇编语言编写，用于测试 CPU 是否正确执行操作，管理人员预计使用 6 - 8 周来开发一套特别复杂的测试。但我仅花了 3 天，用 C 语言编写了一个程序来自动生成测试。</p><p>我并不是为了炫耀而讲这个故事，而是为了引出 “10 倍程序员”。如果你也编写代码，相信你一定听说过有一些程序员的效率是其他人的十倍。这一概念最早来自于 Fred Brooks 的《人月神话》，并自此以后就被广泛讨论。</p><p>有时，学者们也会带着数据加入讨论，其中就包裹了卡内基梅隆大学软件工程研究所的研究人员，他们最近指出：</p><blockquote><p><em>[ … ]虽然有些程序员比其他程序员更好或更快，但这[10倍]差异的规模和有用性被大大夸大了。 经验本身显然是重要的，但它的价值是有限的。</em></p></blockquote><p>他们研究测量了 “努力程度“（完成工作的时间）、代码行数、Bug 数等十项有关编程的指标：</p><blockquote><p><em>[. .] 每种解决方案都涉及简单的输入、输出、模块化以及控制和循环逻辑的使用。 每个故事的大小相当于一个或两个小型敏捷用户故事，需要两个或更多小时才能实现。 学生记录主要活动的时间，需要完成的解决方案，通过所有必要的测试，包括计划，设计，编码，测试和个人审查。</em></p></blockquote><p>而我的经历与这项研究一致：在解决明确定义的问题方面，我不知道有谁会比他们的同行快 10 倍。</p><p>但这些数据也说明了为什么争论仍在持续：<strong>高效的开发者（10 倍或 n 倍）在更高的层面上解决问题。</strong>他们的生产力不会从一个简单的测试中体现，就像世界级的足球明星的技术水平不会说从他们的 100 米短跑中体现一样。</p><p>那些高效的开发者会处理严重的问题，并在必要的设计、架构以及“造轮子还是使用现有库”的决策上带来经验和判断。他们抽象出关键点，并在项目的生命周期中为项目带来好处。他们会寻找那些没有写在计 CS 教科书上的捷径，比如像 Infocom 使用虚拟机将他们的文字冒险游戏移植到一些旧系统的电脑上。（或编写代码来编写 CPU 测试）</p><p>我认为 10 倍开发者，就像顶级运动员、音乐家、作家那样，一定存在。只是你不会通过代码测试来找到他们。</p>]]></content>
    
    
    <categories>
      
      <category>随想杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>程序员</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>译：正确地关闭 Node.js app</title>
    <link href="/2020/02/29/2020/%E8%AF%91_%E6%AD%A3%E7%A1%AE%E5%9C%B0%E5%85%B3%E9%97%AD%20Node.js%20app/"/>
    <url>/2020/02/29/2020/%E8%AF%91_%E6%AD%A3%E7%A1%AE%E5%9C%B0%E5%85%B3%E9%97%AD%20Node.js%20app/</url>
    
    <content type="html"><![CDATA[<p>本文是在阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2020/02/weekly-issue-96.html">科技爱好者周刊：第 96 期</a>中介绍的文章。平时都是 <code>Ctrl + C</code> 简单粗暴来解决，因此来看一下正确关闭 Node.js 程序的姿势。</p><p>英文水平有限，如有错误之处还请指正。</p><hr><h2 id="正文：正确地关闭-Node-js-app"><a href="#正文：正确地关闭-Node-js-app" class="headerlink" title="正文：正确地关闭 Node.js app"></a>正文：正确地关闭 Node.js app</h2><blockquote><p>原文地址： <a href="https://yvonnickfrin.dev/shutdown-correctly-nodejs-apps">Shutdown correctly Node.js apps</a></p></blockquote><p>正确地关闭应用，并防止其处理新的请求是非常重要的。我将以一个服务器应用为例子展开。</p><span id="more"></span><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123;<span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;text/plain&#x27;</span>&#125;);<br>    res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;Hello World\n&#x27;</span>);<br>  &#125;, <span class="hljs-number">4000</span>);<br>&#125;).<span class="hljs-title function_">listen</span>(<span class="hljs-number">9090</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;listening http://localhost:9090/&#x27;</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;pid is &#x27;</span> + process.<span class="hljs-property">pid</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p><img src="https://yvonnickfrin.dev/images/kill-server.gif"></p><p>正如我们所见，服务器没有正确地被关闭，并且请求也没有得到正确的处理。那么为了处理这个问题，首先我们需要明白 Node.js 是如何关闭进程的。</p><p>当关闭进程时，进程会收到一个信号。这些信号有许多<a href="http://man7.org/linux/man-pages/man7/signal.7.html">种类</a>，在这里我们主要关心下面三种。</p><ul><li>SIGINT: 来自键盘 Ctrl + C 的组合（中断进程）</li><li>SIGQUIT: 来自键盘 Ctrl + \（关闭进程）这个操作同时也会生成一个 core 文件</li><li>SIGTERM: 通过系统操作退出(例如使用 kill 命令)</li></ul><p>当进程收到这些信号时，Node.js 会触发事件。因此我们就可以对这些事件编写对应的方法。在下面这个例子中我们将关闭服务器，它会处理完那些被挂起的请求并且不会再接受新的请求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleExit</span>(<span class="hljs-params">signal</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Received <span class="hljs-subst">$&#123;signal&#125;</span>. Close my server properly.`</span>)<br>  server.<span class="hljs-title function_">close</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    process.<span class="hljs-title function_">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;);<br>&#125;<br>process.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;SIGINT&#x27;</span>, handleExit);<br>process.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;SIGQUIT&#x27;</span>, handleExit);<br>process.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;SIGTERM&#x27;</span>, handleExit);<br></code></pre></td></tr></table></figure><p><img src="https://yvonnickfrin.dev/images/kill-server-properly.gif"></p><p>现在我们可以很好的处理请求并正确地关闭服务器。你可以在 <a href="https://twitter.com/nairihar">Nairi Harutyunyan</a> 的 <a href="https://medium.com/hackernoon/graceful-shutdown-in-nodejs-2f8f59d1c357">文章</a> 中找到更多信息。文章对于如何正确地关闭带有数据库的服务器做了详细解释。</p><p>现在还有名为 <a href="https://www.npmjs.com/package/death">Death</a> 的 npm 包可以处理这些逻辑。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">ON_DEATH</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;death&#x27;</span>)<br><span class="hljs-title function_">ON_DEATH</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">signal, err</span>) &#123;<br>  <span class="hljs-comment">// clean up code here</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="有时这样还不够"><a href="#有时这样还不够" class="headerlink" title="有时这样还不够"></a>有时这样还不够</h3><p>最近遇到了这样的场景，我的服务器会接受一个请求来关闭服务器。接下来我会举一些例子。我为服务器订阅了一个 webhook。而这个 webhook 所接受的订阅有限。那么当我不想超出订阅数量时，那我就需要正确地关闭服务器并取消订阅。整个步骤如下：</p><ol><li>向 webhook 发送取消订阅的请求</li><li>webhook 则会向服务器发送确认收到取消订阅的请求</li><li>服务器经过校验，然后取消订阅</li></ol><p>当进程的事件循环为空时，程序就会自动关闭。正如上面的 1、2 步所示，如果事件循环为空，则进程将会终止，我们也将无法成功取消订阅。</p><p>下面将是新的服务器代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>  <span class="hljs-keyword">const</span> params = qs.<span class="hljs-title function_">decode</span>(req.<span class="hljs-property">url</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;?&quot;</span>)[<span class="hljs-number">1</span>]);<br>  <span class="hljs-keyword">if</span> (params.<span class="hljs-property">mode</span>) &#123;<br>    res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>);<br>    res.<span class="hljs-title function_">write</span>(params.<span class="hljs-property">challenge</span>);<br>    res.<span class="hljs-title function_">end</span>();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">let</span> body = <span class="hljs-string">&quot;&quot;</span>;<br>    req.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-function"><span class="hljs-params">chunk</span> =&gt;</span> &#123;<br>      body += chunk;<br>    &#125;);<br>    req.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;event&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(body))<br>      res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>);<br>      res.<span class="hljs-title function_">end</span>();<br>    &#125;);<br>  &#125;<br>&#125;).<span class="hljs-title function_">listen</span>(<span class="hljs-number">9090</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;listening http://localhost:9090/&#x27;</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;pid is &#x27;</span> + process.<span class="hljs-property">pid</span>);<br>  <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;http://localhost:3000/webhook?mode=subscribe&amp;callback=http://localhost:9090&#x27;</span>)<br>&#125;);<br></code></pre></td></tr></table></figure><p>这段代码里有两个变化。当我们在启动服务器时，会向 webhook 服务器发送一个订阅请求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ...</span><br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;http://localhost:3000/webhook?mode=subscribe&amp;callback=http://localhost:9090&#x27;</span>)<br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p>同时我们还在服务器处理请求的方法中添加一个 <code>challenge</code> 的 token，来确认表明 response 来自于 webhook。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">if</span> (params.<span class="hljs-property">mode</span>) &#123;<br>  res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>);<br>  res.<span class="hljs-title function_">write</span>(params.<span class="hljs-property">challenge</span>);<br>  res.<span class="hljs-title function_">end</span>();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br> <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p>让我们再来修改一下 <code>handleExit</code> 方法，让它向 webhook 发送一个请求，告诉它取消订阅。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleExit</span>(<span class="hljs-params">signal</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Received <span class="hljs-subst">$&#123;signal&#125;</span>. Close my server properly.`</span>)<br>  <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;http://localhost:3000/webhook?mode=unsubscribe&amp;callback=http://localhost:9090&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>我们需要添加代码让服务器在 webhook 取消订阅时能够关闭。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">if</span> (params.<span class="hljs-property">mode</span>) &#123;<br>  res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>);<br>  res.<span class="hljs-title function_">write</span>(params.<span class="hljs-property">challenge</span>);<br>  res.<span class="hljs-title function_">end</span>();<br>  <span class="hljs-keyword">if</span> (params.<span class="hljs-property">mode</span> === <span class="hljs-string">&#x27;unsubscribe&#x27;</span>) &#123;<br>    server.<span class="hljs-title function_">close</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      process.<span class="hljs-title function_">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;);<br>  &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p>当 webhook 确认取消订阅时，我们将关闭服务器，这样一来它就不会再处理新的请求并正常地退出。而这也是 Twitch API 中 webhook 的 subscription&#x2F;unsubscription 的工作原理。</p><p>让我们看一下实际关闭服务器时的情况。我添加了一些 log 让其更容易理解。</p><p><img src="https://yvonnickfrin.dev/images/kill-webhook.gif"></p><p>如图所示，服务器并不能正常关闭。服务器的进程在收到 webhook 返回的请求之前就关闭了，因此 webhook 仍然会往服务器发送请求。</p><p>为了解决这个问题，我们需要防止 Node.js 进程退出。我们可以使用 process.stdin.resume 方法。这个方法会使进程暂停并覆盖默认方法，比如 Ctrl + C。</p><p><em>注：我自己跑了一下代码，即使不加 process.stdin.resume 也可以正常取消订阅，但如果不添加 handleExit，就会出现无法取消订阅的情况。</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br>process.<span class="hljs-property">stdin</span>.<span class="hljs-title function_">resume</span>();<br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p>那么现在再来看一下？</p><p><img src="https://yvonnickfrin.dev/images/kill-webhook-properly.gif"></p><p>现在的服务器会在处理完请求后退出。</p><p>我创建了一个 Git 的 <a href="https://github.com/frinyvonnick/node-shutdown-properly-webhooks">repo</a> 上面有文中所提到的代码。</p><p>希望能有所帮助。</p>]]></content>
    
    
    <categories>
      
      <category>随想杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node.js</tag>
      
      <tag>程序学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>全干工程师的自我修养 上手GraphQL</title>
    <link href="/2020/02/26/2020/%E5%85%A8%E5%B9%B2%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%20GraphQL%20%E5%85%A5%E9%97%A8/"/>
    <url>/2020/02/26/2020/%E5%85%A8%E5%B9%B2%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%20GraphQL%20%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/2020/gql.png"></p><p>在前一篇博客 <a href="./%E5%85%A8%E5%B9%B2%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%20%E5%89%8D%E5%90%8E%E7%AB%AF%E4%B8%80%E4%BD%93%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E6%9D%BF.md">全干工程师的自我修养 前后端一体的启动模板</a> 里介绍了自己搭建的启动模板。在这个 <a href="https://github.com/Konata9/faiz-admin">模板项目</a> 中引入了 GraphQL 作为中间层。本文是对自己的学习过程做一个总结，如果理解错误或者不到位的地方，欢迎各位小伙伴指正、交流。</p><h2 id="GraphQL-及其担任的角色"><a href="#GraphQL-及其担任的角色" class="headerlink" title="GraphQL 及其担任的角色"></a>GraphQL 及其担任的角色</h2><span id="more"></span><h3 id="GraphQL-简介"><a href="#GraphQL-简介" class="headerlink" title="GraphQL 简介"></a>GraphQL 简介</h3><p>在正式动手前，先大致了解一下 <a href="https://graphql.cn/">GraphQL</a>。引用官网上的介绍：</p><blockquote><p>GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。</p></blockquote><p>在形式上我们可以简单地理解为，前端编写 SQL 请求向服务端查询或操作数据，返回的数据格式、字段都是由前端来决定的。</p><h3 id="在前后两端中的角色"><a href="#在前后两端中的角色" class="headerlink" title="在前后两端中的角色"></a>在前后两端中的角色</h3><p>在微服务的架构中，GraphQL 可以承担 BFF 的角色来减少前端的请求次数。曾经碰到过一个没有做整合的项目，所有的请求都在前端做，一次又一次的用 id 查详情然后整合，简直就是噩梦……在 GraphQL 出现之前，一般会使用 Node.js 来做这一层。</p><p><img src="https://insights.thoughtworks.cn/wp-content/uploads/2018/03/2-bff-step5.png"></p><p>在一般的单服务架构中，GraphQL 可以取代 Controller 层，来处理业务相关的逻辑。尽可能地保持 DAO 层的简洁。</p><p>而在客户端所担任的角色可以与 Axios 一样，即作为一个发送请求的工具。在 React 里面 Apollo Client 还提供了 Hooks 的实现。</p><h2 id="搭建-GraphQL-Plaground"><a href="#搭建-GraphQL-Plaground" class="headerlink" title="搭建 GraphQL Plaground"></a>搭建 GraphQL Plaground</h2><p>GraphQL 不绑定数据库并且有各个语言的实现。这里使用 <a href="https://www.apollographql.com/docs/apollo-server/">Apollo Server</a> 作为示例。照着官网的示例，我们能很轻松地启动一个 GraphQL Server。</p><ol><li><p>安装依赖</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install apollo-server graphql<br></code></pre></td></tr></table></figure></li><li><p>编写 GraphQL Server: <code>index.js</code></p></li></ol>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">ApolloServer</span>, gql &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;apollo-server&#x27;</span>)<br><span class="hljs-comment">// 定义 Schema</span><br><span class="hljs-keyword">const</span> typeDefs = gql`<span class="language-graphql"></span><br><span class="language-graphql">  <span class="hljs-keyword">type</span> Book<span class="hljs-punctuation">&#123;</span></span><br><span class="language-graphql">    <span class="hljs-symbol">title</span><span class="hljs-punctuation">:</span> String</span><br><span class="language-graphql">    <span class="hljs-symbol">author</span><span class="hljs-punctuation">:</span> String</span><br><span class="language-graphql">  <span class="hljs-punctuation">&#125;</span></span><br><span class="language-graphql"></span><br><span class="language-graphql">  <span class="hljs-keyword">type</span> <span class="hljs-keyword">Query</span> <span class="hljs-punctuation">&#123;</span></span><br><span class="language-graphql">    <span class="hljs-symbol">books</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>Book<span class="hljs-punctuation">]</span></span><br><span class="language-graphql">  <span class="hljs-punctuation">&#125;</span></span><br><span class="language-graphql">`</span><br><span class="hljs-comment">// 定义 Resolver</span><br><span class="hljs-keyword">const</span> resolvers = &#123;<br>  <span class="hljs-title class_">Query</span>: &#123;<br>    <span class="hljs-attr">books</span>: <span class="hljs-function">() =&gt;</span> books,<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// Mock 数据</span><br><span class="hljs-keyword">let</span> books = [<br>  &#123;<br>    <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Harry Potter and the Chamber of Secrets&#x27;</span>,<br>    <span class="hljs-attr">author</span>: <span class="hljs-string">&#x27;J.K. Rowling&#x27;</span>,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Jurassic Park&#x27;</span>,<br>    <span class="hljs-attr">author</span>: <span class="hljs-string">&#x27;Michael Crichton&#x27;</span>,<br>  &#125;,<br>];<br><br><span class="hljs-keyword">const</span> server = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApolloServer</span>(&#123; typeDefs, resolvers &#125;);<br><span class="hljs-comment">// 默认监听 4000 端口</span><br>server.<span class="hljs-title function_">listen</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">&#123; url &#125;</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`🚀  Server ready at <span class="hljs-subst">$&#123;url&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>服务启动之后，我们只要访问服务器地址就可以进入 Playground 界面。我们可以在这里直接进行 GraphQL 的操作，对于上手以及调试非常有帮助。来看一下启动后的效果，左边输入 GraphQL，右边显示结果。自带代码提示，非常亲切。</p><p><img src="/images/2020/gql-playground.gif"></p><h2 id="GraphQL-的基本概念"><a href="#GraphQL-的基本概念" class="headerlink" title="GraphQL 的基本概念"></a>GraphQL 的基本概念</h2><p>梳理清楚 GraphQL 中的基本概念可以减少我们在开发中遇到的困惑。就以上面的 <code>index.js</code> 为例来分步拆解。</p><h3 id="Schema-以及字段类型"><a href="#Schema-以及字段类型" class="headerlink" title="Schema 以及字段类型"></a>Schema 以及字段类型</h3><p>GraphQL 的 Schema 规定了前端可以查询的范围，即允许查询的字段。我们可以使用 Apollo Server 提供的 <code>gql</code> 来包裹字符串。要注意的是，查询没有定义在 Schema 中的字段会直接会抛错。实际上前端所谓能定制字段指的也是在 Schema 范围中的字段。Schema 一般与数据库的字段关联度较高，除去前端参与 GraphQL Server 开发的情况，定义 Schema 是前后端需要互相协商的地方。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> typeDefs = gql`<span class="language-graphql"></span><br><span class="language-graphql">  <span class="hljs-keyword">type</span> Book<span class="hljs-punctuation">&#123;</span></span><br><span class="language-graphql">    <span class="hljs-symbol">title</span><span class="hljs-punctuation">:</span> String</span><br><span class="language-graphql">    <span class="hljs-symbol">author</span><span class="hljs-punctuation">:</span> String</span><br><span class="language-graphql">  <span class="hljs-punctuation">&#125;</span></span><br><span class="language-graphql"></span><br><span class="language-graphql">  <span class="hljs-keyword">type</span> <span class="hljs-keyword">Query</span> <span class="hljs-punctuation">&#123;</span></span><br><span class="language-graphql">    // 定义 <span class="hljs-keyword">Query</span> 的方法和返回值</span><br><span class="language-graphql">    // 这里定义了 books 的方法，返回 Book 对象的数组</span><br><span class="language-graphql">    <span class="hljs-symbol">books</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>Book<span class="hljs-punctuation">]</span></span><br><span class="language-graphql">  <span class="hljs-punctuation">&#125;</span></span><br><span class="language-graphql">`</span><br></code></pre></td></tr></table></figure><p>可以看到上面的定义中，GraphQL 对于每个字段都有类型的要求。GraphQL 中支持的标量类型有 <code>Int</code>，<code>Float</code>，<code>String</code>，<code>Boolean</code> 和 <code>ID</code> 五种。对于复杂类型，常用的是 <code>List</code> 类型以及自定义的 <code>type</code>，如上面的 <code>Book</code> 类型。我们更常用的会是 GraphQL 内置的 Query 和 Mutation type。</p><p>关于更完整的类型支持，可以参考<a href="https://spec.graphql.cn/#sec-Types-">官方文档</a></p><h3 id="Resolver-定义数据处理逻辑"><a href="#Resolver-定义数据处理逻辑" class="headerlink" title="Resolver 定义数据处理逻辑"></a>Resolver 定义数据处理逻辑</h3><p>Resolver 定义 GraphQL 的动作。一般业务逻辑都会放在 Resolver 里面进行处理相当于传统的 Controller 层，最后把处理后的结果返回给前端。</p><p>Schema 和 Resolver 是如何关联起来的呢？在上面的 Schema 中，type Query 中有一个对应的 books，在 type 中决定了 resolver 返回值的类型。而在 Resolver 里面则完成了具体的实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> resolvers = &#123;<br>  <span class="hljs-title class_">Query</span>: &#123;<br>    <span class="hljs-comment">// 这里的 books 对应上面 Schema 中 Query 下的 books</span><br>    <span class="hljs-comment">// 业务逻辑就在后面对应的函数中进行处理</span><br>    <span class="hljs-comment">// 这里的返回值决定了前端获取字段的范围</span><br>    <span class="hljs-attr">books</span>: <span class="hljs-function">() =&gt;</span> books,<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="GraphQL-中对数据的操作"><a href="#GraphQL-中对数据的操作" class="headerlink" title="GraphQL 中对数据的操作"></a>GraphQL 中对数据的操作</h3><h4 id="Query-数据查询"><a href="#Query-数据查询" class="headerlink" title="Query 数据查询"></a>Query 数据查询</h4><p>关于数据的操作，GraphQL 提供了 Query 和 Mutation 两种方法，分别对应着查询与修改操作。进行这两种操作可以简单地理解为调用了对应的 resolver 方法。而对于返回值，GraphQL 也有严格的规定。如果返回的结果是一个对象类型，那么必须指定至少一个字段，不然就会报错。如果需要全部字段的话，那也只能一个个列出来，因为 GraphQL 的返回值是可预测的。</p><p>以上面的代码为例，看一下 Query 操作。</p><figure class="highlight graphql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs graphql">// 默认便是 <span class="hljs-keyword">Query</span> 操作，可以省略前缀 <span class="hljs-keyword">query</span>。但是 <span class="hljs-keyword">Mutation</span> 操作时不能省略<br><span class="hljs-keyword">query</span> <span class="hljs-punctuation">&#123;</span><br>  // 这里对应着 resolver 中的 books<br>  // 相当于调用了 books 方法<br>  books<span class="hljs-punctuation">&#123;</span><br>    // 根据 <span class="hljs-keyword">Schema</span> 中 <span class="hljs-keyword">Query</span> 下 books 的定义<br>    // 返回值是 book 对象的数组<br>    // book 对象拥有 title 和 author 字段<br>    // 必须要指定至少一个字段<br>    title<br>    author<br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>可以看到在 Chrome 中的返回值和我们 query 的结构是相同的。<br><img src="/images/2020/gql-query-data.png"></p><h4 id="Mutation-数据变更"><a href="#Mutation-数据变更" class="headerlink" title="Mutation 数据变更"></a>Mutation 数据变更</h4><p>与 Query 相对应的，操作数据的方法为 Mutation。在书写上与 Query 相同，都需要在 Schema 和 Resolver 中定义好。只是在调用时必须要添加 mutation 关键字。同样再来看一个简单的例子。</p><p>首先我们在 Schema 中定义 Mutation type。在这里我们定义了一个 addBook 的方法，并且指定它的返回值为 Book 类型的 List。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> typeDefs = gql`<span class="language-graphql"></span><br><span class="language-graphql">  // 这里与上面代码相同</span><br><span class="language-graphql">  <span class="hljs-punctuation">...</span></span><br><span class="language-graphql">  // 定义 <span class="hljs-keyword">Mutation</span> 的名字以及返回值</span><br><span class="language-graphql">  <span class="hljs-keyword">type</span> <span class="hljs-keyword">Mutation</span><span class="hljs-punctuation">&#123;</span></span><br><span class="language-graphql">    <span class="hljs-symbol">addBook</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>Book<span class="hljs-punctuation">]</span></span><br><span class="language-graphql">  <span class="hljs-punctuation">&#125;</span></span><br><span class="language-graphql">`</span><br></code></pre></td></tr></table></figure><p>然后在 Resolver 中完成具体的实现。每调用一次 addBook 方法，就会往 books 数组里面插入一条数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> resolvers = &#123;<br>  <span class="hljs-comment">// 这里与上面代码相同</span><br>  ...<br>  <span class="hljs-comment">// Mutation 关键字</span><br>  <span class="hljs-title class_">Mutation</span>: &#123;<br>    <span class="hljs-comment">// 与 type 中对应</span><br>    <span class="hljs-attr">addBook</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      books = [...books, &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;New book&#x27;</span>, <span class="hljs-attr">author</span>: <span class="hljs-string">&#x27;New author&#x27;</span> &#125;]<br>      <span class="hljs-keyword">return</span> books<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>定义完成后，重启服务器然后可以在 Playground 中查看效果。首先来进行一次 Query 操作，查询是可以省略 query 关键字的。<br><img src="/images/2020/gql-mu-query.gif"></p><p>然后我们完成一次 Mutation 操作，mutation 的关键字不能省略。在执行一次操作后，可以看到返回了新的数组。<br><img src="/images/2020/gql-mu-mu.gif"></p><p>最后再来进行一次查询，可以看到数组已经发生了变化。<br><img src="/images/2020/gql-mu-query2.gif"></p><h2 id="引入-TypeScript-以及-TypeGraphQL"><a href="#引入-TypeScript-以及-TypeGraphQL" class="headerlink" title="引入 TypeScript 以及 TypeGraphQL"></a>引入 TypeScript 以及 TypeGraphQL</h2><p>GraphQL 本身的语法简单，因此很容易与 TypeScript 结合。唯一反人类的就是定义 Schema 的 gql 模版语法。这里推荐 TypeGraphQL，这个库允许我们使用 class + 装饰器的方式来定义 Schema 和 Resolver，让代码看起来更加的舒服。下面来把之前的例子用 TypeGraphQL 来重写一下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 请安装 type-graphql 依赖</span><br><span class="hljs-comment">// npm install type-graphql / yarn add type-graphql</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ObjectType</span>, <span class="hljs-title class_">Field</span>, <span class="hljs-title class_">Resolver</span>, <span class="hljs-title class_">Query</span>, <span class="hljs-title class_">Mutation</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;type-graphql&#x27;</span><br><br><span class="hljs-comment">// 定义 Schema</span><br>@<span class="hljs-title class_">ObjectType</span>()<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> &#123;<br>  <span class="hljs-comment">// 相关的字段</span><br>  @<span class="hljs-title class_">Field</span>()<br>  <span class="hljs-attr">title</span>: string<br><br>  @<span class="hljs-title class_">Field</span>()<br>  <span class="hljs-attr">author</span>: string<br>&#125;<br><br><span class="hljs-comment">// 定义 Resolver，传入对应 Schema 进行绑定</span><br>@<span class="hljs-title class_">Resolver</span>(<span class="hljs-title class_">Book</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> &#123;<br>  <span class="hljs-comment">// query 方法</span><br>  @<span class="hljs-title class_">Query</span>(<span class="hljs-function"><span class="hljs-params">returns</span> =&gt;</span> [<span class="hljs-title class_">Book</span>])<br>  <span class="hljs-attr">books</span>: <span class="hljs-function">() =&gt;</span> books<br>  <span class="hljs-comment">// mutation 方法</span><br>  @<span class="hljs-title class_">Mutation</span>(<span class="hljs-function"><span class="hljs-params">returns</span> =&gt;</span> [<span class="hljs-title class_">Book</span>])<br>  <span class="hljs-attr">addBook</span>:<span class="hljs-function">() =&gt;</span> &#123;<br>    books = [...books, &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;New book&#x27;</span>, <span class="hljs-attr">author</span>: <span class="hljs-string">&#x27;New author&#x27;</span> &#125;]<br>    <span class="hljs-keyword">return</span> books<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 其余代码</span><br></code></pre></td></tr></table></figure><p>上面便是最基本也是最常用的写法，更多的写法以及注意点，建议去官方网站查看：<a href="https://typegraphql.ml/">typegraphql</a></p><h2 id="更具体的例子"><a href="#更具体的例子" class="headerlink" title="更具体的例子"></a>更具体的例子</h2><p>通过上面的例子，应该对 GraphQL 的概念和基本用法有一个了解。然而在实际的工作中，我们面对的情况会更加复杂。比如数据需要整合数据库，Query 和 Mutation 如果有参数改怎么做？所以下面会以之前的<a href="https://github.com/Konata9/faiz-admin">模板项目</a>为例，来看一个更具体的例子。</p><h3 id="GraphQL-TypeGraphQL-MongoDB-TypeGoose"><a href="#GraphQL-TypeGraphQL-MongoDB-TypeGoose" class="headerlink" title="GraphQL(TypeGraphQL) + MongoDB(TypeGoose)"></a>GraphQL(TypeGraphQL) + MongoDB(TypeGoose)</h3><p>模板项目使用的数据库是 MongoDB，通常 MongoDB 会使用 Mongoose 作为文档结构（表结构）的定义。在 TypeScript 的项目中，使用 TypeGoose 来代替 Mongoose。TypeGoose 同样也是使用 class + 装饰器来定义文档结构（表结构）。</p><p>鉴于 GraphQL 和 MongoDB 的 Schema 有高度的相似性。那么有聪明的小伙伴肯定猜到了，TypeGoose 与 TypeGraphQL 可以让我们不用重复定义 Schema。</p><p>以模板项目中定义 GraphQL 和 MongoDB 的 User Schema 代码为例，更多的代码可以在<a href="https://github.com/Konata9/faiz-admin">模板项目</a>中查看。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 还是要先安装 type-graphql 和 typegoose 依赖</span><br><span class="hljs-comment">// 导出 type-graphql 的装饰器</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ObjectType</span>, <span class="hljs-title class_">Field</span>, <span class="hljs-variable constant_">ID</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;type-graphql&#x27;</span><br><span class="hljs-comment">// 导出 typegoose 的装饰器</span><br><span class="hljs-keyword">import</span> &#123; prop <span class="hljs-keyword">as</span> mongooseProps, arrayProp, getModelForClass, <span class="hljs-title class_">Ref</span>, modelOptions &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@typegoose/typegoose&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Role</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./role&#x27;</span><br><br><span class="hljs-comment">// 将类包装成 GraphQL 的 Schema</span><br>@<span class="hljs-title class_">ObjectType</span>()<br><span class="hljs-comment">// 将类装饰成为 mongoose 的 Schema</span><br>@<span class="hljs-title function_">modelOptions</span>(&#123; <span class="hljs-attr">schemaOptions</span>: &#123; <span class="hljs-attr">collection</span>: <span class="hljs-string">&#x27;user&#x27;</span> &#125; &#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>  <span class="hljs-comment">// 将字段包装成 GraphQL 的 Field</span><br>  @<span class="hljs-title class_">Field</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable constant_">ID</span>)<br>  <span class="hljs-attr">id</span>: string<br><br>  @<span class="hljs-title class_">Field</span>()<br>  <span class="hljs-attr">token</span>: string<br><br>  @<span class="hljs-title class_">Field</span>()<br>  <span class="hljs-comment">// 这个装饰器会把字段包装成 mongoDB 的字段，即表的字段</span><br>  <span class="hljs-comment">// 不用这个包装器则不会进入表</span><br>  @<span class="hljs-title function_">mongooseProps</span>()<br>  <span class="hljs-attr">username</span>: string<br><br>  @<span class="hljs-title class_">Field</span>()<br>  @<span class="hljs-title function_">mongooseProps</span>()<br>  <span class="hljs-attr">password</span>: string<br><br>  @<span class="hljs-title class_">Field</span>(<span class="hljs-function"><span class="hljs-params">types</span> =&gt;</span> [<span class="hljs-title class_">Role</span>])<br>  <span class="hljs-comment">// 这个装饰器对应数组类型的字段</span><br>  <span class="hljs-comment">// 同时这里使用 ref 关联 Role 表，默认为 _id</span><br>  @<span class="hljs-title function_">arrayProp</span>(&#123; <span class="hljs-attr">itemsRef</span>: <span class="hljs-title class_">Role</span> &#125;)<br>  <span class="hljs-attr">roles</span>: <span class="hljs-title class_">Ref</span>&lt;<span class="hljs-title class_">Role</span>&gt;[]<br><br>  @<span class="hljs-title class_">Field</span>()<br>  @<span class="hljs-title function_">mongooseProps</span>(&#123; <span class="hljs-attr">default</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-property">now</span> &#125;)<br>  <span class="hljs-attr">createTime</span>: <span class="hljs-title class_">Date</span><br><br>  @<span class="hljs-title class_">Field</span>()<br>  @<span class="hljs-title function_">mongooseProps</span>(&#123; <span class="hljs-attr">default</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-property">now</span> &#125;)<br>  <span class="hljs-attr">updateTime</span>: <span class="hljs-title class_">Date</span><br>&#125;<br><span class="hljs-comment">// getModelForClass 创建了 Model</span><br><span class="hljs-comment">// 即 Mongoose 的 Model，可以对表进行数据操作</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">UserModel</span> = <span class="hljs-title function_">getModelForClass</span>(<span class="hljs-title class_">User</span>)<br></code></pre></td></tr></table></figure><p>在上面的例子中，导出的 class 是给 TypeGraphQL 使用，导出的 Model 就可以提供给我们进行数据库操作。如此依赖，两边的 Schema 就整合到了一起。更多关于 TypeGoose 装饰器以及参数设置，可以参考官方文档：<a href="https://typegoose.github.io/typegoose/">TypeGoose</a></p><h3 id="带参数的-Query-和-Mutation"><a href="#带参数的-Query-和-Mutation" class="headerlink" title="带参数的 Query 和 Mutation"></a>带参数的 Query 和 Mutation</h3><p>上面的例子中没有带参数的例子。但实际中，传參是很常见的。那么与上面的 Schema 对应，我们来看一下 User 对应的 Resolver。这里会涉及到关于 Query 和 Mutation 的传參部分。在 TypeGraphQL 中，只要加上 <code>@Arg</code> 装饰器即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Resolver</span>, <span class="hljs-title class_">Query</span>, <span class="hljs-title class_">Arg</span>, <span class="hljs-title class_">Mutation</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;type-graphql&#x27;</span><br><span class="hljs-keyword">import</span> &#123; checkUserExist, findUserById, findUsers, createUser &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@src/controller/user&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">User</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@graphql/schema/user&#x27;</span><br><br><span class="hljs-comment">// 绑定 User Schema</span><br>@<span class="hljs-title class_">Resolver</span>(<span class="hljs-title class_">User</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserResolver</span> &#123;<br>  <span class="hljs-comment">// 使用 Query 查询，且允许返回值为空</span><br>  @<span class="hljs-title class_">Query</span>(<span class="hljs-function"><span class="hljs-params">returns</span> =&gt;</span> <span class="hljs-title class_">Boolean</span>, &#123; <span class="hljs-attr">nullable</span>: <span class="hljs-literal">true</span> &#125;)<br>  <span class="hljs-keyword">async</span> <span class="hljs-title function_">checkUserExist</span>(<span class="hljs-params"></span><br><span class="hljs-params">    <span class="hljs-comment">// Arg 包装器，接受为 string 类型的 username 和 password</span></span><br><span class="hljs-params">    @Arg(<span class="hljs-string">&#x27;username&#x27;</span>) username: string,</span><br><span class="hljs-params">    @Arg(<span class="hljs-string">&#x27;password&#x27;</span>) password: string</span><br><span class="hljs-params">  </span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-title function_">checkUserExist</span>(&#123; username, password &#125;)<br>  &#125;<br><br>  @<span class="hljs-title class_">Query</span>(<span class="hljs-function"><span class="hljs-params">returns</span> =&gt;</span> <span class="hljs-title class_">String</span>, &#123; <span class="hljs-attr">nullable</span>: <span class="hljs-literal">true</span> &#125;)<br>  <span class="hljs-keyword">async</span> <span class="hljs-title function_">user</span>(<span class="hljs-params"></span><br><span class="hljs-params">    <span class="hljs-comment">// 允许参数为空</span></span><br><span class="hljs-params">    @Arg(<span class="hljs-string">&#x27;id&#x27;</span>) id?: string,</span><br><span class="hljs-params">  </span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-title function_">findUserById</span>(id)<br>  &#125;<br><br>  @<span class="hljs-title class_">Query</span>(<span class="hljs-function"><span class="hljs-params">returns</span> =&gt;</span> [<span class="hljs-title class_">User</span>], &#123; <span class="hljs-attr">nullable</span>: <span class="hljs-literal">true</span> &#125;)<br>  <span class="hljs-keyword">async</span> <span class="hljs-title function_">users</span>(<span class="hljs-params"></span><br><span class="hljs-params">    @Arg(<span class="hljs-string">&#x27;username&#x27;</span>, &#123; nullable: <span class="hljs-literal">true</span> &#125;) username?: string</span><br><span class="hljs-params">  </span>) &#123;<br>    <span class="hljs-keyword">const</span> condition = username ? &#123; username &#125; : &#123;&#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-title function_">findUsers</span>(condition)<br>  &#125;<br><br>  @<span class="hljs-title class_">Mutation</span>(<span class="hljs-function"><span class="hljs-params">returns</span> =&gt;</span> <span class="hljs-title class_">User</span>)<br>  <span class="hljs-keyword">async</span> <span class="hljs-title function_">createUser</span>(<span class="hljs-params"></span><br><span class="hljs-params">    <span class="hljs-comment">// Mutation 的参数</span></span><br><span class="hljs-params">    @Arg(<span class="hljs-string">&#x27;username&#x27;</span>) username: string,</span><br><span class="hljs-params">    @Arg(<span class="hljs-string">&#x27;password&#x27;</span>) password: string,</span><br><span class="hljs-params">    <span class="hljs-comment">// 接受数组类型</span></span><br><span class="hljs-params">    @Arg(<span class="hljs-string">&#x27;roles&#x27;</span>, type =&gt; [<span class="hljs-built_in">String</span>], &#123; nullable: <span class="hljs-literal">true</span> &#125;) roles?: string[]</span><br><span class="hljs-params">  </span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-title function_">createUser</span>(&#123;<br>      username,<br>      password,<br>      roles,<br>    &#125;)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">UserResolver</span><br></code></pre></td></tr></table></figure><h3 id="关于鉴权"><a href="#关于鉴权" class="headerlink" title="关于鉴权"></a>关于鉴权</h3><p>实际的项目中，鉴权是绕不开的问题。GraphQL 自然也是有鉴权的。Resolver 对应的处理函数中，有一个 context 参数。在最初初始化的时候，可以绑定到 content 上然后在 resolver 中进行判断。但如此一来，鉴权的逻辑就会侵入到业务代码中。试想如果每个请求都判断是否有 <code>token</code>，那会是非常糟糕的一件事。</p><p>所以在模板项目中，使用了 REST 进行鉴权，比如 <code>/login</code> 等。有关于鉴权也可以参考官方的文章：<a href="https://graphql.cn/learn/authorization/">授权</a></p><h2 id="前端调用"><a href="#前端调用" class="headerlink" title="前端调用"></a>前端调用</h2><p>搭建好了服务端之后，在前端调用 GraphQL 实际上非常简单。其本质和我们使用 RESTApi 一样。利用 Apollo Client 提供的 Client，就可以发送 GraphQL 的请求。</p><p>同样的，来看一下模板项目中前端部分的请求。通常我们会对 client 进行一次封装，就和我们会对 axios 进行封装一样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ApolloClient</span>, <span class="hljs-title class_">ApolloLink</span>, <span class="hljs-title class_">HttpLink</span>, <span class="hljs-keyword">from</span>, <span class="hljs-title class_">InMemoryCache</span>, <span class="hljs-title class_">QueryOptions</span>, <span class="hljs-title class_">MutationOptions</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;apollo-boost&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-variable constant_">STORAGE_KEYS</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@constants&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-variable constant_">CONFIG</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@config&#x27;</span><br><br><span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">apollo</span>: &#123; host, port &#125; &#125; = <span class="hljs-variable constant_">CONFIG</span><br><br><span class="hljs-keyword">const</span> httpLink = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpLink</span>(&#123;<br>  <span class="hljs-attr">uri</span>: <span class="hljs-string">`http://<span class="hljs-subst">$&#123;host&#125;</span>:<span class="hljs-subst">$&#123;port&#125;</span>/graphql`</span>,<br>  <span class="hljs-attr">headers</span>: &#123;<br><br>  &#125;<br>&#125;)<br><br><span class="hljs-comment">// 省略中间代码</span><br><br><span class="hljs-comment">// 创建 client</span><br><span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApolloClient</span>(&#123;<br>  <span class="hljs-attr">link</span>: <span class="hljs-title function_">from</span>([authMiddleware, httpLink]),<br>  <span class="hljs-attr">cache</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">InMemoryCache</span>()<br>&#125;)<br><br><span class="hljs-comment">// 对 Query 进行封装</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">queryGQL</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">&#123;</span><br><span class="hljs-params">  query,</span><br><span class="hljs-params">  variables = &#123;&#125;,</span><br><span class="hljs-params">&#125;: QueryOptions</span>) =&gt; &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// client 提供了 query 方法，允许我们进行查询</span><br>    <span class="hljs-keyword">const</span> &#123; data &#125; = <span class="hljs-keyword">await</span> client.<span class="hljs-title function_">query</span>(&#123; query, variables, <span class="hljs-attr">fetchPolicy</span>: <span class="hljs-string">&#x27;no-cache&#x27;</span> &#125;)<br>    <span class="hljs-keyword">return</span> data<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 对 Mutation 进行封装</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">mutateGQL</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">&#123;</span><br><span class="hljs-params">  mutation,</span><br><span class="hljs-params">  variables = &#123;&#125;</span><br><span class="hljs-params">&#125;: MutationOptions</span>) =&gt; &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// client 提供了 mutation 方法，允许我们进行修改</span><br>    <span class="hljs-keyword">const</span> &#123; data &#125; = <span class="hljs-keyword">await</span> client.<span class="hljs-title function_">mutate</span>(&#123;<br>      mutation,<br>      variables,<br>      <span class="hljs-attr">fetchPolicy</span>: <span class="hljs-string">&#x27;no-cache&#x27;</span><br>    &#125;)<br>    <span class="hljs-keyword">return</span> data<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> client<br></code></pre></td></tr></table></figure><p>而 GraphQL 的查询语句，同样需要用 <code>gql</code> 进行包裹。这里的语法和我们在 Playground 中输入的语法相同，这也就是 Playground 在开发过程中的重要性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">GET_USERINFO</span> = gql`<span class="language-graphql"></span><br><span class="language-graphql">  // 外层的 UserInfo 是 <span class="hljs-keyword">query</span> 名，用于 debug</span><br><span class="language-graphql">  // 并且接受 userId 参数</span><br><span class="language-graphql">  <span class="hljs-keyword">query</span> UserInfo<span class="hljs-punctuation">(</span><span class="hljs-variable">$userId</span>: String<span class="hljs-punctuation">!</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">&#123;</span></span><br><span class="language-graphql">    // 调用 resolver 中的 userInfo 方法，接受 userId 参数</span><br><span class="language-graphql">    userInfo<span class="hljs-punctuation">(</span><span class="hljs-symbol">userId</span><span class="hljs-punctuation">:</span> <span class="hljs-variable">$userId</span>)<span class="hljs-punctuation">&#123;</span></span><br><span class="language-graphql">      // 定义返回的字段</span><br><span class="language-graphql">      nickname</span><br><span class="language-graphql">      avatar</span><br><span class="language-graphql">      phone</span><br><span class="language-graphql">      email</span><br><span class="language-graphql">    <span class="hljs-punctuation">&#125;</span></span><br><span class="language-graphql">  <span class="hljs-punctuation">&#125;</span></span><br><span class="language-graphql">`</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CREATE_USER</span> = gql`<span class="language-graphql"></span><br><span class="language-graphql">  // <span class="hljs-keyword">mutation</span> 也与 <span class="hljs-keyword">query</span> 一样</span><br><span class="language-graphql">  <span class="hljs-keyword">mutation</span> CreateUser<span class="hljs-punctuation">(</span><span class="hljs-variable">$username</span>: String<span class="hljs-punctuation">!</span>, <span class="hljs-variable">$password</span>:String<span class="hljs-punctuation">!</span>, <span class="hljs-variable">$roles</span>: <span class="hljs-punctuation">[</span>String<span class="hljs-punctuation">!</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">&#123;</span></span><br><span class="language-graphql">    createUser<span class="hljs-punctuation">(</span><span class="hljs-symbol">username</span><span class="hljs-punctuation">:</span> <span class="hljs-variable">$username</span>, <span class="hljs-symbol">password</span><span class="hljs-punctuation">:</span><span class="hljs-variable">$password</span>, <span class="hljs-symbol">roles</span><span class="hljs-punctuation">:</span> <span class="hljs-variable">$roles</span>)<span class="hljs-punctuation">&#123;</span></span><br><span class="language-graphql">      id</span><br><span class="language-graphql">    <span class="hljs-punctuation">&#125;</span></span><br><span class="language-graphql">  <span class="hljs-punctuation">&#125;</span></span><br><span class="language-graphql">`</span><br></code></pre></td></tr></table></figure><h2 id="GraphQL-还是-RESTful-？"><a href="#GraphQL-还是-RESTful-？" class="headerlink" title="GraphQL 还是 RESTful ？"></a>GraphQL 还是 RESTful ？</h2><blockquote><p>小孩子才做选择，程序员要看需求</p></blockquote><p>GraphQL 真的能代替 RESTful 吗？对于简单的请求来说，两者其实没有区别。</p><p>那么 GraphQL 的优势在哪呢？我觉得胜在组合与拓展性上，可以类比前端的组件化。这里拿 antd pro 的预览的首页为例。<br><img src="/images/2020/gql-example.png"></p><p>假设每一个图表背后都有一个接口，使用 RESTful 的话，至少需要 8 个接口也就对应着 8 和请求。（实际上根据业务或者表结构，可能会更多）而 GraphQL 只需要一次请求即可。</p><ul><li><p>使用 RESTful 的情况，需要请求多次</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">request</span>(总销售额请求)<br><span class="hljs-title function_">request</span>(访问量)<br><span class="hljs-title function_">request</span>(支付笔数)<br><span class="hljs-title function_">request</span>(运营活动效果)<br></code></pre></td></tr></table></figure></li><li><p>使用 GraphQL 的情况，只需要请求一次</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">query &#123;<br>  总销售额&#123;...&#125;<br>  访问量&#123;...&#125;<br>  支付笔数&#123;...&#125;<br>  运营活动效果&#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>如果把接口整合成一个后，RESTful 在面对需求改动时修改的范围会比较大。</p><ul><li><p>使用 RESTful 的情况，要么使用版本号要么重新开设接口。代码的改动范围较大。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">request</span>(整合后首页请求)<br></code></pre></td></tr></table></figure></li><li><p>而如果使用 GraphQL，只需要在 query 中继续添加即可。只需要后台追加定义，前端也只需要追加query即可代码改动较小。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">query &#123;<br>  总销售额&#123;...&#125;<br>  访问量&#123;...&#125;<br>  支付笔数&#123;...&#125;<br>  运营活动效果&#123;...&#125;<br>  新的接口&#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>引用前端组件化的思想来看，在定义 GraphQL 的 Schema 时尽量原子化，然后通过前端 query 的组合来满足不同的需求。这样一来整个请求就比较灵活，并且对于后端的改动就会比较少。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://graphql.cn/">GraphQL 官网</a></li><li><a href="https://www.apollographql.com/docs/">Apollo Server</a></li><li><a href="https://insights.thoughtworks.cn/use-graphql-build-bff-in-microservices/">微服务下使用GraphQL构建BFF</a></li><li><a href="https://typegoose.github.io/typegoose/">TypeGoose</a></li><li><a href="https://typegraphql.ml/">TypeGraphQL</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>程序学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node.js</tag>
      
      <tag>后端</tag>
      
      <tag>GraphQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>全干工程师的自我修养 前后端一体的启动模板</title>
    <link href="/2020/02/24/2020/%E5%85%A8%E5%B9%B2%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%20%E5%89%8D%E5%90%8E%E7%AB%AF%E4%B8%80%E4%BD%93%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E6%9D%BF/"/>
    <url>/2020/02/24/2020/%E5%85%A8%E5%B9%B2%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%20%E5%89%8D%E5%90%8E%E7%AB%AF%E4%B8%80%E4%BD%93%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="项目动机"><a href="#项目动机" class="headerlink" title="项目动机"></a>项目动机</h2><p>从前到后走一套是一直想做的事情，于是利用这次长假搭建了一个基于 <code>TypeScript</code> 的前后端一体的项目启动模板。即作为自我学习练手，也方便自己之后搭建项目。</p><p>概括来说是一个 <strong>React + Express + MongoDB</strong> 的项目。为了挑战自我，这一次刻意挑选掌握还不全面的 <code>TypeScript</code>，前端方面使用了 <code>styled-component</code> 来进行样式的编写，前后端交互使用 <code>GraphQL</code> 来代替传统的 <code>RESTful</code> 架构。不得不说，熟练度不够外加踩新坑，让搭建初期痛不欲生，甚至几度想放弃。好在风雨之后终见彩虹，项目跑起来之后，感觉自己对 <code>TypeScript</code> 和 <code>GraphQL</code> 也有了一定的认识。</p><p><em>本文从项目角度进行整体介绍，踩过的坑的细节以及搭建中遇到的问题会另写文章单独展开。</em></p><h3 id="Demo-展示"><a href="#Demo-展示" class="headerlink" title="Demo 展示"></a>Demo 展示</h3><p>整个项目是一个启动模板。因为后台系统的通用度相对较高，并且自己也较为熟悉，因此作为本项目的前端页面。当然前端是怎样的都可以。</p><p>项目 GitHub 地址: <a href="https://github.com/Konata9/faiz-admin">Faiz Admin</a>。启动可以参考项目中的 README。</p><p>欢迎小伙伴 clone 下来跑一下，也欢迎 Star，交流，建议，指正。（_在思考项目名的时候，恰巧看到了堆着的假面骑士 Faiz 的模型，便以此为项目名。_）</p><span id="more"></span><p>在介绍项目之前，可以先来看一下项目的页面。因为只是模板项目，所以在功能上仅实现了登录、登出、用户以及角色的添加和查询等最基础（通用）的功能。毕竟实际工作中需求多种多样，需要具体情况具体应对了。</p><p><img src="/images/2020/faizAdmin-login.gif" alt="登陆页"><br><img src="/images/2020/faizAdmin-content.gif" alt="内容页"></p><h2 id="技术栈梳理"><a href="#技术栈梳理" class="headerlink" title="技术栈梳理"></a>技术栈梳理</h2><p>从前到后涉及的知识面比较广泛，所以将本项目主要的知识点整理成下面的导图方便梳理。技术栈更多的是个人的喜好，前后端的框架均可以换成自己顺手的框架。</p><p><img src="/images/2020/FullStack.png" alt="涉及技术导图"></p><h3 id="项目语言：TypeScript"><a href="#项目语言：TypeScript" class="headerlink" title="项目语言：TypeScript"></a>项目语言：TypeScript</h3><p>采用 <code>TypesScript</code> 的好处已经不用赘述。尽管在代码量上会因为 <code>interface</code> 的关系会增加不少，以及刚上手时把人折磨得半死的类型提示错误，但在 Debug 上会轻松许多，大多的 Bug 都偏向业务逻辑，而语法上的错误基本没有了。</p><p>目前主流框架都已支持 <code>TypeScript</code> （Vue 3.0 将完全支持），从面向简历编程的角度来说也应该学习起 <code>TypeScript</code> 了。只要躺过了类型错误的坑，coding 就会舒服很多，<code>TypeScript</code> 的强类型也迫使在写代码时要思考的更加严谨。（可以多利用一下 VSCode 的提示）</p><h3 id="前端框架：React"><a href="#前端框架：React" class="headerlink" title="前端框架：React"></a>前端框架：React</h3><p>三大主流框架中选择 <code>React</code>，主要还是隔个人喜欢函数式自由的风格以及 Hooks，在本项目中也基本都使用 Hooks。UI 方面，Material UI 太依赖与 Google Font 和 Icon，对于国内来说可能不太方便；微软的 Fabric UI 浓浓的 Office 风格，很多组件还是需要自己进行封装。所以最终还是选择回了 antd。</p><p>在状态管理方面，实在不愿意去手写 <code>action</code> 和 <code>reducers</code>，于是使用了 <code>mobx</code>。这样就能在一个 <code>class</code> 中完成数据状态的管理了。没有了 <code>action</code> 和 <code>reducer</code>，代码也干净很多。另外封装了一个全局 <code>loading</code> 来实现类似 <code>dva</code> 中 <code>loading.effects[xxx]</code> 的效果。</p><p>与后端通信方面以 ApolloClient 和 Axios 结合使用。ApolloClient 是比较常用的 GraphQL 客户端，与服务端的 ApolloServer 配套（其实分开使用也没事），主要负责 GraphQL 部分。Axios 用来负责 RESTful 的接口，用于不需要权限的 api，如 <code>/login</code>。这里的划分主要和 GraphQL 的鉴权机制有关。</p><h3 id="后端框架：Express-ApolloServer"><a href="#后端框架：Express-ApolloServer" class="headerlink" title="后端框架：Express + ApolloServer"></a>后端框架：Express + ApolloServer</h3><p>Express 一定不会陌生，最早出现的服务器框架，插件丰富第三方支持也很不错。这一次使用的 Apollo Server、TypeGraphQL 都主要以 Express 为例子。文档上的支持越好，后期 Debug 时也越方便。后端这边最大变化就是引入了 ApolloServer 以及 GraphQL 相关的功能。剩下的其实和正常的后端服务器完全相同。</p><h3 id="数据库：MongoDB"><a href="#数据库：MongoDB" class="headerlink" title="数据库：MongoDB"></a>数据库：MongoDB</h3><p>在数据库方面，这次采用了 MongoDB。一方面是现在工作中使用，另一方面搭建起来简单，直接使用 Docker 即可。</p><p>数据库的 ORM 毫无意外的就是 Mongoose，本项目自然用的是 TypeScript 版本的 <code>TypeGoose</code>，并且可以与 <code>TypeGrahQL</code> （定义 GraphQL Schema 类型的库）的 Schema 可以公用，能有效减少重复 coding。毕竟 Mongoose 的 Schema 在一定程度上和 GraphQL 的 Schema 有关联。要维护两份相同的文件简直就是噩梦……</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>在上面简单地介绍了一下技术栈，接下来就来看一下项目的目录结构。</p><p>整个项目划成 <code>frontend</code> 和 <code>server</code> 两部分，即前端和服务端。使用 <code>TypeScript</code> 后会有许多 <code>interface</code>，关于 <code>interface</code> 是统一放到一个文件夹中管理还是分散在文件中这个问题一直困扰着我。在这个项目里面主要还是分散在各个文件中自行管理（尽管建了最外层文件夹）。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs stylus">.<br>├── frontend <span class="hljs-comment">// 前端工程文件</span><br>│   ├── config <span class="hljs-comment">// 全局配置文件</span><br>│   │   └── index<span class="hljs-selector-class">.ts</span><br>│   ├── index<span class="hljs-selector-class">.html</span><br>│   ├── locale <span class="hljs-comment">// 国际化文本文件</span><br>│   │   └── zh_CN<br>│   ├── package<span class="hljs-selector-class">.json</span><br>│   ├── public <span class="hljs-comment">// 静态资源文件</span><br>│   ├── <span class="hljs-attribute">src</span><br>│   │   ├── client<span class="hljs-selector-class">.ts</span> <span class="hljs-comment">// ApolloClient </span><br>│   │   ├── constants <span class="hljs-comment">// 常量文件夹</span><br>│   │   ├── global<span class="hljs-selector-class">.d</span><span class="hljs-selector-class">.ts</span><br>│   │   ├── index<span class="hljs-selector-class">.tsx</span> <span class="hljs-comment">// 入口文件</span><br>│   │   ├── interface <span class="hljs-comment">// interface 文件夹</span><br>│   │   ├── pages <span class="hljs-comment">// 页面文件夹</span><br>│   │   ├── service <span class="hljs-comment">// 处理 effects 以及 Query 语句</span><br>│   │   ├── store <span class="hljs-comment">// mobx store 文件</span><br>│   │   └── utils <span class="hljs-comment">// 工具函数</span><br>│   ├── tsconfig<span class="hljs-selector-class">.json</span><br>│   ├── webpack<br>│   │   ├── webpack<span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.js</span><br>│   │   └── webpack<span class="hljs-selector-class">.dev</span><span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.js</span><br>│   └── yarn<span class="hljs-selector-class">.lock</span><br>└── server <span class="hljs-comment">// 服务端工程文件</span><br>    ├── config <span class="hljs-comment">// 全局配置文件</span><br>    │   └── index<span class="hljs-selector-class">.ts</span><br>    ├── database<span class="hljs-selector-class">.ts</span> <span class="hljs-comment">// 数据库链接 (Mongoose)</span><br>    ├── dbInit<span class="hljs-selector-class">.ts</span> <span class="hljs-comment">// 数据库初始化文件</span><br>    ├── index<span class="hljs-selector-class">.ts</span> <span class="hljs-comment">// 入口文件 Express + ApolloServer</span><br>    ├── logger <span class="hljs-comment">// 日志存放文件夹</span><br>    ├── nodemon<span class="hljs-selector-class">.json</span><br>    ├── package<span class="hljs-selector-class">.json</span><br>    ├── <span class="hljs-attribute">src</span><br>    │   ├── constants <span class="hljs-comment">// 常量文件夹</span><br>    │   ├── controller <span class="hljs-comment">// 数据库 CRUD 操作部分</span><br>    │   ├── graphql <span class="hljs-comment">// GraphQL 的 Schema &amp; resolver，GraphQL 与 Mongoose 的 Schema 可以公用</span><br>    │   ├── router <span class="hljs-comment">// 路由文件，处理 RESTful 的接口</span><br>    │   └── utils <span class="hljs-comment">// 工具函数</span><br>    ├── tsconfig<span class="hljs-selector-class">.json</span><br>    └── yarn.lock<br></code></pre></td></tr></table></figure><h2 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h2><p>现在的模板项目中已经涉及了很多知识与框架，但严格来说还有更进一步的空间。</p><p>大部分集中在服务端，比如日志管理模块（log4js)；服务启动后用于监视的 pm2；可以增加 Redis 来缓解数据库压力；多个服务之间通信的消息队列……总之，能更进一步的空间还有很大。</p><p>关于日志以及 pm2 的部分将会是接下来打算做的部分。</p>]]></content>
    
    
    <categories>
      
      <category>程序学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>程序员</tag>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>译：程序员该做好低收入的准备</title>
    <link href="/2020/02/14/2020/%E8%AF%91_%E7%A8%8B%E5%BA%8F%E5%91%98%E8%AF%A5%E5%81%9A%E5%A5%BD%E4%BD%8E%E6%94%B6%E5%85%A5%E7%9A%84%E5%87%86%E5%A4%87/"/>
    <url>/2020/02/14/2020/%E8%AF%91_%E7%A8%8B%E5%BA%8F%E5%91%98%E8%AF%A5%E5%81%9A%E5%A5%BD%E4%BD%8E%E6%94%B6%E5%85%A5%E7%9A%84%E5%87%86%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<p>程序员在现在仿佛意味着高收入，BAT 的光环以及时不时流出的某某大厂年终奖 1x 个月的消息更是让人们对这一职业心生向往。只是事实真的如此吗？</p><p>本文是在阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2020/02/weekly-issue-94.html">科技爱好者周刊：第 94 期</a>中看到的，觉得会给我们一些启示，所以翻译出来顺便练手。英文水平有限，如有错误之处还请指正。</p><hr><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><blockquote><p>原文地址： <a href="https://www.jefftk.com/p/programmers-should-plan-for-lower-pay">https://www.jefftk.com/p/programmers-should-plan-for-lower-pay</a></p></blockquote><p>前言：我们并不明白为何程序员的收入如此之高。如果你恰好是程序员，要相信这很可能是暂时的，因此对未来做一个明确的规划是非常值得的，因为你很可被解雇并且无法找到类似的高薪工作。</p><span id="more"></span><p>考虑到成为一名程序员需要付出很多，所以程序员会有非常高的收入。下面是 <a href="https://danluu.com/bimodal-compensation/">Dan Luu 的与其他高薪职业的比较</a></p><blockquote><p>如果你想做律师，那么你就需要获得很高的声望然后进入一所名校，这会花费数十万美元。然后还是要获取更好的名声，取得更好的成绩从而进入一家顶尖的公司。然为了避免被踢出局，你仍然需要绷紧神经，这就需要你牺牲个人时间了。咨询、投行也是如此。薪酬与你牺牲的程度成正比。（比如投行收入会比律师更高，但投入的时间也会更长）</p></blockquote><blockquote><p>而就牺牲个人时间这点来看，医学似乎要好一点。因为医学领域有进入的门槛和限制。但与在 Facebook 和 Google 工作相比，医学院和住院医师的制度结合仍然是非常残酷的。</p></blockquote><p>我的妹妹现在是一个工作两年的住院医生，对我来说 “非常残酷…” 放在她身上简直是轻描淡写。她每周工作大约 80 个小时，通常在晚上，帮助人们解决一些个人隐私和痛苦方面的问题，然而在下班之后也很难忘记这些问题。而这还是在医学院读了 4 年之后，并且还需要一年才能真正达到医生级别的薪资。而当我把这与我大学毕业后开始学习编程，赚更多的钱却只要每周工作 40 小时不用待机的经历相比，结果让我很尴尬。</p><p>但让我紧张的是，我们并不能真的明白为什么程序员的收入会如此之高，并且为什么这种情况会持续下去。</p><p>人们对此有许多猜测：</p><ul><li>需求：随着软件席卷全球，程序员要做的事情比一般人要多的多。</li><li>供给：培养一个程序员很困难，真正适合这个工作的人比预想的要少，而所谓的培训班效果也不如人们预期。</li><li>创业：大厂需要与那些离职创业的程序员竞争，这在其他行业很难做到。</li><li>前沿：这个领域相对前沿，而新的领域也会带来更高的利润和薪水，又或许是竞争机制还不成熟？</li><li>其他：我非常好奇其他人是怎么想的，欢迎留言！</li></ul><p>尽管目前一切都很好，并且似乎自 <a href="https://danluu.com/bimodal-compensation/">Dan 2015 年的文章</a>之后市场变得更好，但世事无常。考虑到我们对此知之甚少，并且未来也多种多样，我想我们应该做好最坏的打算：不是一定会发生的事情，也不是会在未来特定时间范围发生的事情，而是那些大概率发生的事情。</p><p>具体来说，我建议缩减日常开支并且存下大部分收入。削减开支远比维持开支要来得痛苦，但是你节省的时间越久，你的处境就会越好。如果你采取这种方法并且没有遭遇失败，那么你的处境会很好，你可以选择提早退休或者支持一些你喜欢的事情。</p><p>如果被解雇并且不能找到类似的高薪工作会成为一场灾难的话，那么赶紧找出你需要作出哪些改变从而避免灾难的发生。</p><p>（这篇文章并不特指编程领域，但我认为在编程领域出现的概率会高于比其他成熟领域。）</p>]]></content>
    
    
    <categories>
      
      <category>随想杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>程序员</tag>
      
      <tag>职业生涯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从日本官僚制随想互联网 35 岁裁员</title>
    <link href="/2020/02/04/2020/%E4%BB%8E%E6%97%A5%E6%9C%AC%E5%AE%98%E5%83%9A%E5%88%B6%E9%9A%8F%E6%83%B3%E4%BA%92%E8%81%94%E7%BD%91%2035%20%E5%B2%81%E8%A3%81%E5%91%98/"/>
    <url>/2020/02/04/2020/%E4%BB%8E%E6%97%A5%E6%9C%AC%E5%AE%98%E5%83%9A%E5%88%B6%E9%9A%8F%E6%83%B3%E4%BA%92%E8%81%94%E7%BD%91%2035%20%E5%B2%81%E8%A3%81%E5%91%98/</url>
    
    <content type="html"><![CDATA[<p>假期里看了半佛老师的<a href="https://www.bilibili.com/video/av84552259">你不知道的互联网30年秘史</a>，回顾了中国互联网澎湃的历史。回味之余也想起了自己在日本的工作经历，就莫名联想到了互联网的裁员风波与日本的官僚制度，于是便有了这篇博客。因此 <strong>本文纯为个人兴起而作，随想成分较大，仅供参考，欢迎小伙伴们来交流。</strong></p><h2 id="官僚下凡与日本的官僚制度"><a href="#官僚下凡与日本的官僚制度" class="headerlink" title="官僚下凡与日本的官僚制度"></a>官僚下凡与日本的官僚制度</h2><blockquote><p>官僚下凡：特指离职后的中央高级官僚接受再就职斡旋，以便获得其出身部委所管辖的外围团体、关联企业、独立行政法人、国立大学法人以及特殊法人等机构的高级职位。</p></blockquote><p>在学习日语的时候，老师曾简单地介绍过日本的官僚制度。俗话说 “一人得道，鸡犬升天”，然而在日本公务员中却是相反的情况。同期（同一时间进入政府机构的人）的公务员只有 1 人能晋升局至级以上职位，其余人则会被劝退。只是在拥有终身雇用制文化的日本，人事部门在奖励被劝退的人一笔可观的退职金之外，还要为他们安排再就业岗位。这些被劝退的公务员由于精通管理并且在政商两界拥有大量的人脉，自然也受到民间企业的青睐。一般都能在关联企业中，担任高管。对于日本的公务员来说，“升天” 还是 “下凡” 或许都不错。</p><span id="more"></span><p>在 ”论资排辈，等级森严“ 的日本，一起进公司的同期成了自己的顶头上司，对双方来说今后的工作都会成为一个难题。管理者该如何管理？下面的人又会否不服呢？“官僚下凡” 的制度就在某种程度上解决了这一个问题。那么再回过来看看国内。</p><h2 id="30-年与-35-岁"><a href="#30-年与-35-岁" class="headerlink" title="30 年与 35 岁"></a>30 年与 35 岁</h2><p>自 <strong>2017</strong> 年华为 “集中清理34岁以上交付工程维护员工” 风波之后，35 岁对于互联网人来说成为了一道坎。 尽管华为事后否认此事，但从近年来知乎、京东、阿里等各大厂的 “结构优化” 与 “向社会输出优秀人才” 的情况来看，这似乎是业界默认的事实。这里的 <strong>2017</strong> 年是一个需要记住的时间点。</p><blockquote><p>以史为鉴，可以知兴替</p></blockquote><p>自 2000 年新浪、搜狐、网易在美国上市，互联网终于开始爆发。2002 年门户网站开启了第一波热潮，2011 年移动端领域兴起。随后，2013 年至 2017 年，O2O 大战开启，互联网迎来了黄金时代。对年份敏感的小伙伴可能察觉到了，如果一个本科应届生在 2000 年左右加入互联网，那么在 2017 年大概在 40 岁左右。顺带一提，去年的 “251” 事件的受害者也是 41 岁。</p><p>“再无风清扬，再有少年郎” 30 年浪潮之后，互联网相对传统行业依旧年轻。顶端的大佬早已无人不知，只是在金字塔形的公司架构里，那些没能晋升的同龄人是否也会被 “下凡” 呢？</p><h2 id="现实往往更加复杂。"><a href="#现实往往更加复杂。" class="headerlink" title="现实往往更加复杂。"></a>现实往往更加复杂。</h2><p>互联网的黄金时代中，换工作工资就能翻一倍是确实存在的事实。“官僚下凡” 尽管在形式上与互联网的裁员相似，但公务员与资本终究是不同的。被 “下凡” 的官僚拥有丰富的从政管理经验以及人脉而被企业青睐，而经历了互联网黄金时代的人却只有着高薪。技术圈的变化之快也让这些人在技术经验上，不占优势。</p><p>资本是逐利的，而国内互联网 996 的风气也让这项脑力劳动趋近于体力劳动。那么，在偏基础的职位上为什么不用薪资更低的年轻人呢？被 “下凡” 的人也又该如何转身呢？</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="http://www.sirpa.shisu.edu.cn/d0/48/c270a118856/page.htm">俞祖成：日本的官僚制与“官僚下凡”</a></li><li><a href="https://www.bilibili.com/video/av84552259">你不知道的互联网30年秘史</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>随想杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>程序员</tag>
      
      <tag>求职</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工作 7 年的些许感悟</title>
    <link href="/2020/01/31/2020/%E5%B7%A5%E4%BD%9C%207%20%E5%B9%B4%E7%9A%84%E4%BA%9B%E8%AE%B8%E6%84%9F%E6%82%9F/"/>
    <url>/2020/01/31/2020/%E5%B7%A5%E4%BD%9C%207%20%E5%B9%B4%E7%9A%84%E4%BA%9B%E8%AE%B8%E6%84%9F%E6%82%9F/</url>
    
    <content type="html"><![CDATA[<p>突如其来的疫情打乱了大部分人过年的节奏，延长的假期也让人过得不是滋味。愿疫情能尽快稳定，也祝看博客的小伙伴们无论何时都身体健康，百毒不侵。</p><p>工作之后时间真的过的飞快，从 2013 年毕业至今也快 7 年了。自从大三入了前端这个坑之后，就再也没出来过。此方至今一共换过 3 次工作，先去了日本做派遣，回国后做前端，最近又转职成了后端，也算是全干工程师了。这篇博客既可以是对自己工作经历的回顾，也可以算是对上一篇<a href="./%E8%81%8A%E8%81%8A%E5%B9%B4%E5%90%8E%E6%8D%A2%E5%B7%A5%E4%BD%9C%E7%9A%84%E4%BA%8B%E6%83%85%E5%90%A7.md">聊聊年后换工作的事情吧</a>的补充吧。</p><span id="more"></span><h2 id="顺势而为，事半功倍"><a href="#顺势而为，事半功倍" class="headerlink" title="顺势而为，事半功倍"></a>顺势而为，事半功倍</h2><blockquote><p>人的一生当然要靠自我奋斗，当然也要考虑历史的进程</p></blockquote><p>从现在来看，2013 年互联网行业开始兴起，余额宝也是在那一年推出的。大量网站的兴起让前端有了巨大需求，当时是真的不看出身，会干活就能找到工作。在这一年进入互联网行业的人，到现在相信不是大牛就是大佬了。此方当年毕业时曾有幸拿到了网易暴雪前端的 offer，然而当时却因为一心想去日本而选择了一家对日的软件公司。现在回想起来，内心五味杂陈。虽然出了国门见了世面，也了却了自己的心愿，但也因为自己的年轻错失赶上风口的机会。（真的对不起当年网易好心劝我的 HR 姐姐 ……）</p><p>顺带一题，当年 B 站也去面过实习生，当时他们招 PHP 而此方学的是 Java……（嗯，当年前后端都学过了）。然而现在 B 站后端又转到 Go 了……</p><p>看着国内活跃的互联网，再想想自己错过的网易。于是此方又重新学起了前端。每天早起，下班后做完家务学 Vue 写 Demo，上慕课、Coursera。虽然很累，但也多亏了这段时间的充电让我养成了学习的习惯。回国后就开始前端生涯，在工作中学习项目经验，打牢 JavaScript 的基础知识之后，又顺利转成了后端（没错，就是 Node.js 开发）。硬要说工作上编程的经历，其实也不过 3 年。只不过世事变迁，如今的大环境和当年不同了，资本寒冬悄然来临……</p><p>回过头来看，正确的选择会放大自己的努力成果。在工作之余，多观察一下市场总是有益的。</p><h2 id="优秀的背景与学历，永远是很好的敲门砖"><a href="#优秀的背景与学历，永远是很好的敲门砖" class="headerlink" title="优秀的背景与学历，永远是很好的敲门砖"></a>优秀的背景与学历，永远是很好的敲门砖</h2><blockquote><p>让自己变得优秀会让机会更多</p></blockquote><p>此方两次换工作都是通过猎头。在交流的过程中，猎头也会关注年龄、学历以及背景。是的，明面上用人单位在招聘时不能限定 985、211，但实际上还是会对学校和工作经历进行考量。然而互联网市场经过这些年的发展也逐渐稳定，各个岗位对人才的要求也逐渐提高。另一个就是公司体量大了，需要一批好背景的员工来做品牌。也曾听到某厂要招一批本科学历的员工来换掉专科员工的小道消息，尽管不知真假。但随着前后端门槛越来越高，“互联网行业不看学历” 恐怕也要成为历史了。大 Fenng 老师的这篇文章<a href="https://mp.weixin.qq.com/s/4vQpQ12lVHV1RMHI35hWBg">为什么大公司招人会看重学历？</a>写得非常犀利。</p><p>而此方自己尽管工作经历不行（对日和互联网差别太大），但因为学校还算好，顺利从对日转成了前端，而后也一步步去了更好的公司。中间尽管走了不少的弯路，但没有自己的学校，可能走的弯路会更多。</p><p>只是好的学校和背景未必人人都会有，剩下能做的也只能靠自己的努力了。对于我们做技术的人来说，打牢基础在项目中丰富自己的经验，然后不断地打磨自己。一旦敲开了门就能丰富自己的背景，从而一步步提高。</p><h2 id="适时而动，不同年龄对应着不同需求"><a href="#适时而动，不同年龄对应着不同需求" class="headerlink" title="适时而动，不同年龄对应着不同需求"></a>适时而动，不同年龄对应着不同需求</h2><blockquote><p>摆正需求，调整心态。是我们都要经历的过程</p></blockquote><p>如同软件一样，人在不同的年龄段也对应着不同的需求。认识自己的需求和所处的状态才能作出合适的选择。</p><p>对于刚刚毕业的年轻人来说，一份大厂的经历毫无疑问对自己的未来是非常的有帮助的。此时的年轻人没有家庭、房贷的包袱，这个时候比起稳定，更可以选择拼搏一下拓宽今后职场的选择。市场是现实的，有哪个公司会不想要一个有着大厂背景的人呢？年轻人也可以一步一步去到更好的平台，获取更好的资源。当然，此方是反对 996、007 的，只是现实是无奈的，资本也是无情的。</p><p>对于步入而立之年的小伙伴来说，一般都有了家庭也有了房贷，那么此时工作的稳定性要更为重要，只有稳定的收入才能支撑起这些，任何一次裁员都是非常大的动荡。此时换工作的话更是要慎重，光看着钱去可能会栽跟头。建议看看 stormzhang 在他公众号的文章<a href="https://mp.weixin.qq.com/s/pxJVSf7e6IdMByomPuXWdA">我斗胆 BB 几句网易裁员事件</a>。</p><h2 id="居安思危，不断学习才是立身之本"><a href="#居安思危，不断学习才是立身之本" class="headerlink" title="居安思危，不断学习才是立身之本"></a>居安思危，不断学习才是立身之本</h2><blockquote><p>Stay Hungry, Stay Foolish</p></blockquote><p>技术的世界永远都在变化，各式各样的工具和框架都在不停的涌现（特别是前端）。在日本工作的经历，让我养成了学习的习惯，也让我明白了不断学习的重要性。即便如阮一峰老师这样的大牛，也在不停的学习（最近他在介绍 deno <a href="http://www.ruanyifeng.com/blog/2020/01/deno-intro.html">Deno 运行时入门教程：Node.js 的替代品</a>)，我们又怎能放松呢？</p><p>回想起某次面试的时候，HR 直言 __“我们公司没有 35 岁以上的程序员”__。这话着实吓到了我，也给我敲响了警钟。资本无情，面对如此现实，也只有不断学习才能维持立身之本。这里的学习不光是我们程序上的学习，还有 “软技能” 的学习。《软技能》、《未来世界幸存者》、《前方的路》，这些书中都给我们指出了方向。在钻研技术之余，也不妨看看这些。</p><p>前路漫漫，我们一起努力。</p>]]></content>
    
    
    <categories>
      
      <category>随想杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>程序员</tag>
      
      <tag>求职</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>聊聊年后换工作的事情吧</title>
    <link href="/2020/01/25/2020/%E8%81%8A%E8%81%8A%E5%B9%B4%E5%90%8E%E6%8D%A2%E5%B7%A5%E4%BD%9C%E7%9A%84%E4%BA%8B%E6%83%85%E5%90%A7/"/>
    <url>/2020/01/25/2020/%E8%81%8A%E8%81%8A%E5%B9%B4%E5%90%8E%E6%8D%A2%E5%B7%A5%E4%BD%9C%E7%9A%84%E4%BA%8B%E6%83%85%E5%90%A7/</url>
    
    <content type="html"><![CDATA[<p>年后一直都是换工作的高峰，身边一些小伙伴也正有此意。恰巧此方我也在去年换了一份工作，所以趁着春节长假就整理一下，聊聊自己的经验。在这里也祝各位看文章的小伙伴们新年快乐，身体健康，年后能大涨工资或者收获一份心仪的工作。</p><p>友情提示：<strong>本文为个人观点，仅供小伙伴们参考，也欢迎互相交流。</strong></p><h2 id="寒冬真的存在，所以时机很重要"><a href="#寒冬真的存在，所以时机很重要" class="headerlink" title="寒冬真的存在，所以时机很重要"></a>寒冬真的存在，所以时机很重要</h2><blockquote><p>“2019可能会是过去10年最差的一年，但却是未来10年最好的一年”</p></blockquote><p>美团董事长王兴的话，暗示了大环境的严峻。2019 年互联网公司裁员新闻一直不断，先有清退 35 岁以上程序员，再有神州优车 HR 工位宣读裁员信息，最后还有马云爸爸要给社会“输出”在阿里工作十年的人才。寒冬是真实存在的，因此找工作的时机尤为重要。</p><span id="more"></span><p>就此方自己的经验，避开“金三银四”，“金九银十”的求职高峰是一个不错的选择。这个时候尽管开放的职位多，但求职者更多。那些拿了年终奖再出来的小伙伴也都有几把刷子，因此竞争压力会比较大，对于公司方面选择范围广、议价空间也大。此方去年 11 月在面试某团的时候，面试的 HR 也很直接地告诉我，如果是年后我很可能就拿不到 offer 了。</p><p>在年底如果有职位出现，要么是有人离职出现空缺、要么就是有新项目会在年后正式启动。一面是公司对于人员是有需求的，而另一面是大多数小伙伴因为年终奖不太会选择离职。此时对于求职的小伙伴就比较有利了。特别是像此方这样对自身实力不是很有自信的情况下，就有机会能去到一个大一点的平台。当然其中利弊需要大家自己权衡。</p><h2 id="打牢基础，以不变应万变"><a href="#打牢基础，以不变应万变" class="headerlink" title="打牢基础，以不变应万变"></a>打牢基础，以不变应万变</h2><blockquote><p>“Talk is cheap, show me the code”</p></blockquote><p>Linus 大神的话对于对我们写代码的小伙伴应该不会陌生。offer 都是留给做足准备的人。作为一个“前”前端（是的，此方现在已经转职成全干工程师了），吃透 JavaScript 的基础永远是获得 offer 的捷径。</p><p>前端的工程化以及 JavaScript 所占的比重越来越大，基础的掌握程度也决定了未来的上升空间。毕竟框架年年都会有，只会用框架的“工具人”对于大厂来说根本不缺。对于业务场景更加复杂特殊，核心技术需要自研的大厂来说，扎实的基础更为重要。像谷歌、微软这样的巨厂更是重视基础中的基础——算法，如果算法不过关会被直接挂掉（此方就直接死在算法上了）。</p><p>刷题是必不可少的过程，在去年的博客<a href="./../2019/%E6%98%AF%E6%97%B6%E5%80%99%E4%BF%9D%E6%8C%81%E5%A4%87%E6%88%98%E7%8A%B6%E6%80%81%E4%BA%86.md">是时候保持备战状态了</a>里，安利了一些刷题的 Repo。对于有时间的小伙伴来说，刷题之外熟读“红宝书”（《JavaScript 高级程序设计》）、阮一峰老师的《ES6 入门教程》非常有必要。准备面试都需要花时间的，保守估计至少要准备 2 周以上（最好 1 个月以上）。毕竟面试的时候各种犄角旮旯的问题都会有……</p><ul><li><p><a href="https://github.com/haizlin/fe-interview">前端面试每日 3+1（每日三问）</a><br>每天都会有三题，HTML、CSS、JS 各一题，有些问题是真的平时没有想到过的（倒不一定真的是面试题），查漏补缺、突击面试必备。只是问题没有固定的答案，都是大家零碎的回答。</p></li><li><p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question">Daily-Interview-Question</a><br>木易杨大大出品，深度讲解一个个知识点。对基础上做一个深度上的进阶。</p></li><li><p><a href="https://github.com/xiaomuzhu/front-end-interview">前端开发者面试清单</a><br>一个较为系统性的面试清单。作者非常贴心地做了 PWA，可以在上下班的路上阅读。配合【前端面试每日 3+1】一起查漏补缺。</p></li></ul><p>在此方自己的公众号 <strong>此方的手账</strong> 里也整理了去年自己面试美团时候的面试题，一共面了三个部门共 27 道题，分别是基础技术部、到店广告部、企业研发部。有需要的小伙伴在关注公众号后回复“<strong>美团</strong>”即可，或许就能理解为什么要准备 1 个月以上了。</p><h2 id="靠谱的公司比工资更重要"><a href="#靠谱的公司比工资更重要" class="headerlink" title="靠谱的公司比工资更重要"></a>靠谱的公司比工资更重要</h2><p>换工作最终的目的，一定是要找家靠谱的公司。所谓”钱多、事少、离家近“是终极目标。相信也有不少小伙伴是被互联网的高薪所吸引。正如之前所说，互联网泡沫破裂寒冬来临。也正因如此，前些年风口时期的盛世高薪也风景不再。</p><p>在寒冬里，此方认为靠谱的公司比工资更为重要。996、007 都是高工资的代价。很多小伙伴都会觉得只要钱给够，这些都能接受。但这其实是挤占了不愿意加班的人的份额，当所有人都选择 996 的时候，这个份额就没有了。更何况有些公司还喜欢卖情怀，只管 996 不管加班费，不满意了再灌输点危机意识……等 35 岁榨干了劳动力之后，再裁掉拖着病体的你……</p><p>所以不妨在接 offer 时考虑一下时薪，再根据自己的年龄、身体情况和家庭情况，职位的稳定程度也要纳入考虑。年轻的小伙伴可以以公司平台为主，拓宽今后的道路。但要注意身体，之前网易的事情，告诉我们身体才是最大的本钱，没有身体都没法赚钱。而年纪大一点的小伙伴要考虑家庭情况，稳定的工作和收入也是对家庭最大的保障，任何一次裁员风波在这个时候都是一次动荡。再说个个人经验，那些爱卖情怀、把造福社会、造福他人口号挂在嘴边的公司，要留个心眼。</p><p>最后，<strong>本文为个人观点，仅供小伙伴们参考</strong>。对于大牛类型的小伙伴可以无视上面的一切，毕竟大牛无论什么时候、无论哪家大厂都会抢着要的。也祝暂时还没成为大牛的小伙伴，早日成为大牛，实现财务自由。</p>]]></content>
    
    
    <categories>
      
      <category>随想杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>程序员</tag>
      
      <tag>求职</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用Label标签定制个性化Radio按钮</title>
    <link href="/2019/08/28/2019/%E5%88%A9%E7%94%A8Label%E6%A0%87%E7%AD%BE%E5%AE%9A%E5%88%B6%E4%B8%AA%E6%80%A7%E5%8C%96Radio%E6%8C%89%E9%92%AE/"/>
    <url>/2019/08/28/2019/%E5%88%A9%E7%94%A8Label%E6%A0%87%E7%AD%BE%E5%AE%9A%E5%88%B6%E4%B8%AA%E6%80%A7%E5%8C%96Radio%E6%8C%89%E9%92%AE/</url>
    
    <content type="html"><![CDATA[<div style="text-align:center">  <img width="100%" src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1567010872446&di=643c73b12b35ff32d8fec3e5db6d15fe&imgtype=0&src=http%3A%2F%2F04imgmini.eastday.com%2Fmobile%2F20190507%2F20190507194423_ce095d193a1e71b6856248d8d7bfbbf6_1.jpeg"></div><p>在最近的项目中，遇到了类似下图的单选按钮。<br><img src="/images/pay-radio.jpg"></p><p>Radio 按钮的默认样式并不好看，经常成为被修改样式的对象。而常用的 antd 中，Radio 组件也没有提供可用于自定义的属性。当然，这些是难不倒各位前端小伙伴的，只要利用好 <code>label</code> 标签就能很简单地实现一个个性化 Radio 按钮组件。</p><p>CSS3 目前基本都得到了支持，所以配合 CSS3 就能减少我们在 JS 上的处理。这一次主要涉及如下知识点：</p><ul><li><code>label</code> 标签的使用</li><li><code>:checked</code> 伪类的使用</li><li><code>::before/after</code> 伪元素的使用</li></ul><p>实际完成的效果如下图（由于偷懒，很多就用文字代替了）：<br><img src="/images/radio-example.jpg"></p><span id="more"></span><p>想看代码的小伙伴也可以来这里：<a href="https://codepen.io/Konata9/pen/QWLvEyb?editors=0111">利用 Label 定制个性化 Radio 按钮</a></p><p>整个 Radio 的核心思想，就是利用 <code>label</code> 与 radio 的互相关联。这样在点击 <code>label</code> 的时候，radio 按钮也会跟着联动。<code>label</code> 与表单控件的关联分为显示和隐式两种。显示即我们熟悉的 <code>for</code> 属性关联表单控件的 <code>id</code>，而隐式则是把表单控件包裹在 <code>label</code> 标签中。在我们的例子中，采用的是隐式关联的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;label <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;label-wrapper&quot;</span> style=&#123;labelStyle&#125; onChange=&#123;handleChange&#125;&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#123;id&#125;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;name&#125;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;value&#125;</span> /&gt;</span></span><br>  <span class="hljs-comment">// 辅助的 div 在例子里面用来显示边框等自定义样式</span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;content&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/label&gt;<br></code></pre></td></tr></table></figure><p>为了方便对样式的控制，我们需要调整一下 <code>label</code> 的默认样式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.label-wrapper</span> &#123;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br></code></pre></td></tr></table></figure><p>下一步就是利用到 <code>:checked</code> 伪类，来控制选中和非选中的样式。对应我们的例子，就是 <code>input</code> 下面的 <code>div</code> 的样式。而对于简单的图案，如边框、右上角的选中标示，其实还可以利用 <code>::before/after</code> 伪元素来实现。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">input</span><span class="hljs-selector-pseudo">:checked</span> + <span class="hljs-selector-tag">div</span> &#123;<br>  // 通过 <span class="hljs-attribute">padding</span> 解决抖动问题<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">5px</span> solid lightblue;<br><br>  &amp;<span class="hljs-selector-pseudo">::after</span> &#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;@&quot;</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">top</span>: -<span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">right</span>: <span class="hljs-number">1px</span>;<br>  &#125;<br><br>  &amp;<span class="hljs-selector-pseudo">::before</span> &#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0px</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">15px</span> solid lightblue;<br>    <span class="hljs-attribute">border-left-color</span>: transparent;<br>    <span class="hljs-attribute">border-bottom-color</span>: transparent;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如此一来，一个简单的自定义 Radio 按钮就实现出来了。根据需求我们可以监听 <code>onChange</code> 事件等来实现我们想要的功能。另外，只要利用 radio 相同 <code>name</code> 就会互斥的性质，就能实现按钮组的效果。</p><p>最后再提一下，想看代码的小伙伴也可以来这里：<a href="https://codepen.io/Konata9/pen/QWLvEyb?editors=0111">利用 Label 定制个性化 Radio 按钮</a></p><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>这一次利用 CSS 伪类来实现自定义 Radio 按钮，主要是受到最近刷题中 CSS 题目的启发。虽然现在前端的重点在 JavaScript 上，但 HTML 与 CSS 仍然是逃不开的内容。CSS3 提供了许多伪类和新的属性，利用好伪类可以减少我们在 JavaScript 上的工作量。所以在空闲之时不妨多翻两眼 CSS3 吧。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>前端</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>是时候保持备战状态了</title>
    <link href="/2019/08/25/2019/%E6%98%AF%E6%97%B6%E5%80%99%E4%BF%9D%E6%8C%81%E5%A4%87%E6%88%98%E7%8A%B6%E6%80%81%E4%BA%86/"/>
    <url>/2019/08/25/2019/%E6%98%AF%E6%97%B6%E5%80%99%E4%BF%9D%E6%8C%81%E5%A4%87%E6%88%98%E7%8A%B6%E6%80%81%E4%BA%86/</url>
    
    <content type="html"><![CDATA[<p>夏天已经过去，但互联网的寒冬似乎还在。原因就是今年开始各类的面试题收集的项目突然就冒出来了。除去大环境的经济因素外，还有互联网的泡沫已经过去。互联网发展至今，各个领域的用户群也被瓜分得差不多了。大厂也纷纷站住脚跟，从之前的野蛮生长，吸引用户转向了精耕细作，留住客户的方向。</p><p>但是市场上的 HC 却似乎并没减少。需要精耕细作和提高用户体验的大厂或者互联网企业依旧需要人。只是这一次需要的是高级或资深级别的人。这一现象在一向被认为门槛”偏低“的前端，也逐渐显露出来。也正因为如此，面试题类型的项目也如雨后春笋般地出现。</p><p>作为一个程序员，”保持学习“一直是我认为应该养成的习惯和态度。不过我自己在实际执行的过程中，却又总觉得似乎缺了一点什么。直到我看到了这些面试题库以及开始刷题之后才发现，缺少的那一点正是紧张感。</p><span id="more"></span><p>那何为紧张感呢？面对每日都可能出现的新技术，前端圈中似乎出现了一个词叫做“前端焦虑”。“焦虑”的背后或许正是这份紧张感。打一个比喻的话，每一个选择成为程序员的人就像是武士。除了每天挥剑锻炼之外，也要有随时准备上战场的紧张感。如果缺少这种紧张感，即便每天都有锻炼，等一踏上战场也会一时束手无策。</p><p>所以除了保持学习外，我们还应该让自己保持在备战状态，如同一把随时可以出鞘的利剑。回想一下高三时不停刷各种模拟卷的场景，就能知道保持备战状态最简单的方法，就是利用好这些面试题的项目。面试题通常会从基础、常用、通用、深入等几个方面切入，在做题的过程中不仅可以帮助我们查漏补缺，可能给我们一些新的启发。（这段时间我对于 CSS 又有了新的理解）</p><p>下面是我平时自己参考学习的项目，因为精力有限因此从零碎、系统、专精上分别找了一个 Star 数较多的项目来跟。</p><ul><li><p><a href="https://github.com/haizlin/fe-interview">前端面试每日 3+1（每日三问）</a> Star: 5552<br>每天都会有三题，虽然有些零碎，但是有些问题是真的平时没有想到过的（倒不一定真的是面试题），刷一刷可以查漏补缺。问题没有固定的答案，都是大家零碎的回答。我自己做了一份回答的 Repo: <a href="https://github.com/Konata9/fe-interview-answer">fe-interview-answer</a> 作为自己的习题集。（目前在死命地追上更新的步伐）</p></li><li><p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question">Daily-Interview-Question</a> Star 6677<br>不多说了，木易杨大大出品，深度讲解一个知识点。对基础上做一个深度上的进阶。</p></li><li><p><a href="https://github.com/xiaomuzhu/front-end-interview">前端开发者面试清单</a> Star: 1516<br>一个较为系统性的面试清单。作者非常贴心地做了 PWA，可以在上下班的路上阅读。很配【前端面试每日 3+1】。Vue Express 的排版真的挺好看的。</p></li></ul><p>最后，学习和保持备战状态固然很累，但既然都是选择了程序员道路的人。相信一定是体会过其中乐趣的吧。</p>]]></content>
    
    
    <categories>
      
      <category>随想杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>程序员</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于前端未来方向的思考</title>
    <link href="/2019/07/14/2019/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF%E6%9C%AA%E6%9D%A5%E6%96%B9%E5%90%91%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <url>/2019/07/14/2019/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF%E6%9C%AA%E6%9D%A5%E6%96%B9%E5%90%91%E7%9A%84%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<p>2019 已过去一半，前端社区关于前端未来发展的文章最近也多了起来。最近看到了阿里大佬谈未来前端的文章便也有了一些自己的思考，建议没有看过文章的小伙伴可以去看看。</p><blockquote><p><a href="https://mp.weixin.qq.com/s/8at9sidaa2H1XNqRyuqPkw">阿里前端委员会主席圆心：未来前端的机会在哪里？</a></p></blockquote><p>虽说正式从事前端时间不算很长，不过最早接触前端是在 2012 年左右，也就是上文的第二阶段末期。但从我个人的感受来看，那时的前端还是连带着切图的第一阶段。开局一个 <code>div</code>，配合 Sublime 项目直接开搞。浏览器兼容全靠手、js 引入顺序全靠脑。当时找工作的话，<strong>PS + jQuery + div</strong> 布局足以（如果切图好的话可能还是加分项），会用 <code>ExtJs</code> 的话，当时算是王者了。</p><div style="display:flex;justify-content:center">  <img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1563121583636&di=832614e26778d4f40098b0af130226dc&imgtype=0&src=http%3A%2F%2Fwww.soft711.com%2Fuploadfile%2F2014%2F1101%2F20141101020145234.png" alt="photoShop" width="256" style="dispaly:inline-block;"/>  <img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=821957021,1449380298&fm=26&gp=0.jpg" alt="jQuery" width="256" height="256" style="margin-left: 20px;display:inline-block;"></div><p>而之后的两年因为工作内容和前端关系不大，也就关心的较少了。等再次回归的时候，已经是 <code>Angular</code>、<code>React</code> 和 <code>Vue</code> 的“三国”时代了。要搞项目也是 <code>Webpack</code> 起手的工程化流程。浏览器的兼容也有了预处理器来搞定，切图也移给 UI 去做了，前端更多的是负责 JavaScript 的数据和交互处理以及基于 Node.js 的 BFF（Backend For FrontEnd）部分。</p><p>勉强地来说，我也算是经历过了前端发展早期阶段了。回过来看最大的一个感受就是前端开发正变得和后端开发越来越像。如今的 <code>Webpack</code> 起手就和当年在 eclipse 中新建一个 Java 工程，而 <code>npm</code> 就和 Maven、Gandle 一样。<code>flux</code> 式的数据管理模式中也能看到 MVC 的影子。</p><p>为什么前端会发展成现在这样呢？回顾一下历史，可以发现 <code>Ajax</code> 的成熟应用为前后端的分离埋下了伏笔。后端可以更关注于数据层面，把渲染和交互还给前端。SPA 或者说富应用的概念也就在这个时候出现了，而随着硬件和网络条件的发展，SPA 和富应用也逐渐变得可能。</p><span id="more"></span><div style="text-align:center">  <img src="https://image.slidesharecdn.com/routinginspa-130620050546-phpapp01/95/routing-in-spa-5-638.jpg?cb=1371704897" /></div><p>前后端分离，也让软件的架构从 C&#x2F;S 变为了 B&#x2F;S。但软件的本质其实并没有变化。前端拿回的数据处理的部分正是后端所擅长的。于是 Backbone 这样的 MVC 框架就出现了。数据层的问题解决之后，还有另一个无法避免的问题，那就是 UI 的更新。传统的 DOM 操作在面对复杂项目时编写和维护就是开发者的噩梦，同时大量的 DOM 操作也会带来性能上的问题。于是 Virtual DOM 和 MVVM 的框架也就顺势出现了。只不过 MVVM 也不是前端发明的，最早是在微软的 WPF 上出现。</p><p>另一个推手就是 Node.js。Node.js 的出现让前端程序员没有门槛地编写前端需要的各种工具。模块化、预处理器、打包工具也随之出现。当然，一部分后端程序员把他们在后端的经验搬来也是有一定影响的。</p><p>再结合到业务上来说，现在前端的工程基本都是基于各种 <code>cli</code> 脚手架起步。除了注重交互的 C 端外，大部分的中台管理系统由于逻辑以 CRUD 为主，脚手架外加 UI 库就能很快搭建起来。那么这一部分也就很容易用工程化代替。中台系统的构建以及 CRUD 为主的系统将被简化。（小伙伴们有听说过阿里的飞冰吗？）</p><p>所以从这个角度来看的话，未来前端向“前”的会更向前，往“后”的会更往后。向“前”更注重交互，会模糊与 UI 之间的界限（或者干脆合并），这部分可能会需要 CSS 结合 UI 的艺术细胞（重 C 端）；而向“后”则更靠近近后端，Node.js 为主的 BFF 层会是另一个方向（比如前端基础组建的搭建、工程化工具的开发和维护），这部分可能就需要扎实的基本功了。还有一个方向是图形学相关的技术（WebGL、Canvas），因为图形学受制于目前的硬件，在前端方面还相对较少，当然这一部分应该是需要扎实的数学功底了。虽然现在的一部分工作可能会被工具简化，但 IOT 和 AR&#x2F;VR 技术的成熟也会进一步扩大前端的范围，只是用的语言是不是还是 JavaScript 就不知道了。</p><p>以上便是我个人对前端未来方向的一些思考，大部分还是从个人的角度出发，如有不足之处还欢迎交流指正。</p>]]></content>
    
    
    <categories>
      
      <category>随想杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>程序员</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>H5 中数字 input 的处理</title>
    <link href="/2019/06/09/2019/H5%20%E4%B8%AD%E6%95%B0%E5%AD%97%20input%20%E7%9A%84%E5%A4%84%E7%90%86/"/>
    <url>/2019/06/09/2019/H5%20%E4%B8%AD%E6%95%B0%E5%AD%97%20input%20%E7%9A%84%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<div style="text-align:center;"><img src="http://img.yxbao.com/article/image/201904/30/1c02044545.png" /></div><p>对于数字相关的输入，我们会使用 HTML5 提供的 <code>type=&quot;number&quot;</code> 来处理。number 类型的 <code>input</code> 只允许我们输入与数字有关的内容（0-9，小数点、正负号以及表示科学计数法的 e）</p><blockquote><p>可以在下面的输入框中尝试一下<br>type&#x3D;”number” 的 input : <input type="number"></p></blockquote><p>然而在实际的业务场景中，<code>type=&quot;number&quot;</code> 并不能满足我们，比如禁止输入小数点和正负号的需求。因为在输入 <code>. + - e</code> 的时，<code>input</code> 的 <code>onChange</code> 事件时不会有响应的，除非当输入是一个合法的数字。例如我们输入 <code>----1</code> 或者 <code>....3</code> 时，<code>onChange</code> 并不会有任何反应。也即我们失去了对 input value 的判断机会。</p><p>当然，利用 <code>onKeyUp</code> 或者 <code>onKeyDown</code> 来监听按键来进行控制也是可以的。不过我更喜欢换回 <code>type=&quot;text&quot;</code> 配合正则进行处理。这招在 PC 端上问题不大，但是在移动端上却会产生另一个问题——唤起键盘的样式。</p><span id="more"></span><hr><p>在移动端中，input 的 <code>type=&quot;number&quot;</code> 唤起的是数字键盘；<code>type=&quot;text&quot;</code> 时唤起的是英文键盘。因此当遇到禁止输入小数点、正负号的需求时，要么说服产品，要么就只能自己想办法。不过现实中我们往往会（无奈地）选择后者。</p><p>一个虚拟键盘应该可以满足各种需求。不过，自己实现虚拟键盘不仅费时费力，很可能还要根据不同的系统进行样式的修改，如果没有现成的库显然是不太实际的方案。</p><p>那又能否利用 <code>onKeyUp</code> 和 <code>onKeyDown</code> 事件呢？然而手机（我的是小米）上 <code>. + -</code> 的按键都是 <strong>229</strong>，很显然这是没有办法做判断的。如果第一个就输入 <code>. + -</code>，那么 <code>e.target.value</code> 是空。即便是合法的数字如 <code>-1</code>、<code>+1</code> 也不满足禁止输入 <code>+ -</code> 的需求。</p><div style="text-align:center;"><img src="http://ww1.sinaimg.cn/large/9150e4e5gw1f9stmncqg3j205a05aglk.jpg" /></div><p>那么是不是就没有办法了呢？再次梳理一下需求，在移动端我们需要点击 <code>input</code> 时唤起数字键盘，并且不允许输入非数字外的值（包括小数点、正负号）。</p><p>查看 MDN 之后发现 HTML5 中 <code>input</code> 有个 <code>tel</code> 的 type。<code>&lt;input type=&quot;tel&quot; /&gt;</code> 正好可以满足我们的需求。顾名思义 <code>type=&quot;tel&quot;</code> 是用来输入电话号码的，唤起的是号码键盘（与数字键盘很相似）。尽管不是真正的数字键盘(iOS 上可以看到两者的区别)，但也基本满足了我们的需求了。而另一个最重要的特点就是，<code>type=&quot;tel&quot;</code> 与 <code>type=&quot;text&quot;</code> 类似，可以利用 <code>onChange</code> 对所有输入进行监听，这也就意味着我们可以对输入的值进行控制了。</p><p>尽管这是一个投机取巧的办法，不过用在移动端上确实非常有用。下次如果遇到移动端的数字输入的情况，不妨可以考虑一下 <code>type=&quot;tel&quot;</code> 这个属性。</p>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>前端</tag>
      
      <tag>H5 开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些提高开发效率的小体会</title>
    <link href="/2019/04/16/2019/%E4%B8%80%E4%BA%9B%E6%8F%90%E9%AB%98%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%E5%B0%8F%E4%BD%93%E4%BC%9A/"/>
    <url>/2019/04/16/2019/%E4%B8%80%E4%BA%9B%E6%8F%90%E9%AB%98%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%E5%B0%8F%E4%BD%93%E4%BC%9A/</url>
    
    <content type="html"><![CDATA[<p>最近在工作中遇到了比较紧急的项目，短时间以及不能再删减（甚至还可能会变）的需求就意味着要尽可能地提升开发效率。前端因为与交互相关，因此会受到大部分需求变更的影响。如何尽可能地减少因需求变更而产生的工作量，一直以来都困扰着前端开发人员。</p><p>由于自己平时的代码风格还不够规范以及知识领悟不深，自然我也没少受苦，但也因此对提高开发效率方面有了一些体会。本文便是总结与复盘，用于日后提醒自己。</p><h3 id="如何提高效率"><a href="#如何提高效率" class="headerlink" title="如何提高效率"></a>如何提高效率</h3><p>对于我们做开发的同学来说，提高工作效率最有效的方法就是<strong>降低 BUG 率</strong>；而降低 BUG 率最有效的方法就是减少代码量。还记得 GitHub 上之前大火的项目 <a href="https://github.com/kelseyhightower/nocode">No Code</a> 吗？资深的谷歌工程师告诉我们，一行代码都没有的程序是最安全的稳定的。</p><p>其次如果<strong>代码拓展性</strong>足够强，那么在面对需求变更时的工作量就会相对减少（作为前端，不变更时不存在的）。而增强代码拓展性比较常用的方法就是通用组件的封装与抽象。</p><p>下面就是有关于这两部分的一些总结和思考。</p><h3 id="降低-BUG-的方法"><a href="#降低-BUG-的方法" class="headerlink" title="降低 BUG 的方法"></a>降低 BUG 的方法</h3><p>良好的代码风格应该是降低 BUG 最有效的方法，可以参考《代码整洁之道》一书。下面的一些方法是我在平时工作中所总结出来的几点。</p><h4 id="1-减少代码量"><a href="#1-减少代码量" class="headerlink" title="1. 减少代码量"></a>1. 减少代码量</h4><p>代码量越少也就越难出现 BUG。在平时的工作中，应该尽可能地减少编写的代码量。在前端中，最简单的就是尽量使用 ES6 语法。相比 ES5，通过 ES6 的解构、箭头函数、async&#x2F;await 可以减少 30% 以上的代码量。在有大量（3 个以上）的 <code>if</code> 判断时，可以使用对象的形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 常规赋值操作</span><br><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span><br><span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span><br><span class="hljs-keyword">let</span> c = <span class="hljs-number">3</span><br><span class="hljs-comment">// 使用解构赋值</span><br><span class="hljs-keyword">let</span> [a,b,c] = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><br><span class="hljs-comment">// 使用 if</span><br><span class="hljs-keyword">if</span>(a === <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>  ....<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a === <span class="hljs-string">&#x27;2&#x27;</span>)&#123;<br>  ...<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a === <span class="hljs-string">&#x27;3&#x27;</span>)&#123;<br>  ....<br>&#125;<br>...<br><br><span class="hljs-comment">// 使用对象进行分类处理， 逻辑上会更简洁一点</span><br><span class="hljs-comment">// PS：这个方法在 React 进行组件渲染的时候非常有用</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleAction</span> = (<span class="hljs-params">act</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> actions = &#123;<br>    <span class="hljs-string">&#x27;1&#x27;</span>: action1,<br>    <span class="hljs-string">&#x27;2&#x27;</span>: action2,<br>    <span class="hljs-string">&#x27;3&#x27;</span>: action3<br>  &#125;<br>  <span class="hljs-keyword">const</span> action = actions[act]<br>  <span class="hljs-title function_">action</span>()<br>&#125;<br><span class="hljs-comment">// 根据情况进行处理</span><br><span class="hljs-title function_">handleAction</span>(<span class="hljs-string">&#x27;1&#x27;</span>)<br></code></pre></td></tr></table></figure><span id="more"></span><p>在 React 的项目中，如果使用了 Redux。那么应该尽可能地使用 <code>function</code> 组件来减少代码。同时这么做也可以让我们在进行 UI 移植的时候省下很多改动（最近有一个项目是部分功能的迁移，<code>Redux -&gt; dva</code> 在移植 <code>function</code> 组件时几乎没有什么改动），而且现在有了 Hook，<code>function</code> 组件中不能控制 <code>state</code> 的问题也能解决。</p><h4 id="2-设定默认值"><a href="#2-设定默认值" class="headerlink" title="2. 设定默认值"></a>2. 设定默认值</h4><p>缺少默认值非常容易造成 BUG，这是之前一个项目中血和泪的教训。特别是 React 项目中使用了上面介绍的对象的方法进行组件切换时，如果没有设置默认值就会直接造成页面崩溃。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title class_">Components</span> = &#123;<br>    <span class="hljs-comment">// 特别是根据 Response 来进行组件切换时，应该设置 default 防止意外情况</span><br>    <span class="hljs-attr">A</span>: <span class="hljs-title class_">Component1</span>,<br>    <span class="hljs-attr">B</span>: <span class="hljs-title class_">Component2</span>,<br>    <span class="hljs-attr">C</span>: <span class="hljs-title class_">Component3</span>,<br>    <span class="hljs-string">&#x27;default&#x27;</span>: <span class="hljs-function">() =&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> /&gt;</span></span><br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">const</span> &#123;render&#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span><br>    <span class="hljs-comment">// 如果没有默认值，一旦对象匹配不到，页面直接崩溃</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title class_">RenderComponent</span> = <span class="hljs-title class_">Components</span>[render] || <span class="hljs-title class_">Components</span>.<span class="hljs-property">default</span><br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">RenderComponent</span> /&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其次函数参数的默认值除了能减少 BUG 外也能帮助减少代码量。对于使用次数较多的方法，直接设置默认值可以让我们在调用时省去参数的传入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 当 0.0.0.1 和 api service 方法较多时，设为默认参数可以减少参数的传入</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">customizeFetch</span>(<span class="hljs-params">service=<span class="hljs-string">&#x27;api&#x27;</span>, base = <span class="hljs-string">&#x27;0.0.0.1&#x27;</span></span>)&#123;<br>  ...<br>&#125;<br><br><span class="hljs-title function_">customizeFetch</span>()<br></code></pre></td></tr></table></figure><h4 id="3-拆分函数与抽象方法"><a href="#3-拆分函数与抽象方法" class="headerlink" title="3. 拆分函数与抽象方法"></a>3. 拆分函数与抽象方法</h4><p>说到拆分函数，用的最多的应该是 <code>request</code> 的应用部分。比如对 <code>fetch</code> 的封装。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 封装好的 fetch (有柯里化的影子在)</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">customizeFetch</span>(<span class="hljs-params">server = <span class="hljs-string">&quot;api&quot;</span>, base = <span class="hljs-string">&quot;0.0.0.1&quot;</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">api = <span class="hljs-string">&quot;&quot;</span>, options = &#123;&#125;, withAuth = <span class="hljs-literal">false</span></span>) &#123;<br>    <span class="hljs-keyword">const</span> url = <span class="hljs-string">`<span class="hljs-subst">$&#123;base&#125;</span>/<span class="hljs-subst">$&#123;server&#125;</span>/<span class="hljs-subst">$&#123;api&#125;</span>`</span>;<br>    <span class="hljs-keyword">const</span> opts = &#123;<br>      <span class="hljs-attr">method</span>: options.<span class="hljs-property">method</span> || <span class="hljs-string">&quot;POST&quot;</span>,<br>      <span class="hljs-attr">headers</span>: &#123;<br>        <span class="hljs-comment">// 可以设置默认参数，比如头什么的</span><br>        ...options.<span class="hljs-property">headers</span><br>      &#125;,<br>      <span class="hljs-attr">body</span>: &#123;<br>        ...options.<span class="hljs-property">body</span><br>      &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(url, opts).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>());<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 当我们进行调用时，对于业务来说写起来基本一致</span><br><span class="hljs-comment">// 由于使用透传，其实在 service 还能偷懒写成一个方法</span><br><span class="hljs-comment">// 产品列表</span><br><span class="hljs-keyword">const</span> fetchAPI = <span class="hljs-title function_">customizeFetch</span>(<span class="hljs-string">&quot;api1&quot;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">getProductList</span> = opts =&gt; &#123;<br>  <span class="hljs-keyword">const</span> options = &#123;<br>    <span class="hljs-attr">body</span>: &#123; ...opts &#125;<br>  &#125;;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetchAPI</span>(<span class="hljs-string">&quot;getProductList&quot;</span>, options);<br>&#125;;<br><br><span class="hljs-comment">// 新闻列表</span><br><span class="hljs-keyword">const</span> fetchAPI = <span class="hljs-title function_">customizeFetch</span>(<span class="hljs-string">&quot;api2);</span><br><span class="hljs-string">const getNewsList = opts =&gt; &#123;</span><br><span class="hljs-string">  const options = &#123;</span><br><span class="hljs-string">    body: &#123; ...opts &#125;</span><br><span class="hljs-string">  &#125;;</span><br><span class="hljs-string">  return fetchAPI(&quot;</span>getNewsList<span class="hljs-string">&quot;, options);</span><br><span class="hljs-string">&#125;;</span><br></code></pre></td></tr></table></figure><h4 id="4-强类型和强检查"><a href="#4-强类型和强检查" class="headerlink" title="4. 强类型和强检查"></a>4. 强类型和强检查</h4><p><code>eslint</code> 的好处就不用提了吧？再配合 <code>prettier</code> 可以让代码格式统一（<code>umi</code> 的 <code>lint</code> 虽然在不习惯时会觉得很烦，但是一旦习惯后对代码风格的提升还是很有帮助的）。如果再用上 <code>TypeScript</code> 更是可以让我们在编码时检查到错误。<code>TypeScript</code> 虽然在刚开始使用时很不习惯，特别是对于类型的强要求（全部 <code>any</code> 的话等于没有类型）很头痛。不过适应之后就能体会到 <code>TypeScript</code> 带来的快感了。</p><p>在引入 <code>TypeScirpt</code> 之后，最容易出现的 <code>xxx from undefined</code> 错误就能完全避免。可以帮助我们节省下许多调试的时间。</p><h3 id="应对需求变更"><a href="#应对需求变更" class="headerlink" title="应对需求变更"></a>应对需求变更</h3><p>前端的组件化开发，在更多的程度上是为了应对需求的变更（个人认为）。而由于前端是最接近用户的，因此只要需求有变是逃不过要进行一番修改的。因此让修改的工作量减少以及减少因修改带来的 BUG，也是提高效率的方法。</p><h4 id="1-提升副作用，尽量使用-Stateless-组件"><a href="#1-提升副作用，尽量使用-Stateless-组件" class="headerlink" title="1. 提升副作用，尽量使用 Stateless 组件"></a>1. 提升副作用，尽量使用 Stateless 组件</h4><p>对于 React&#x2F;Vue 项目，只要使用了 Redux&#x2F;Vuex 这类状态管理工具，我们就能很容易地把组件做成不依赖于 <code>state</code> 的 <code>stateless</code> 组件。这类组件很“纯”基本只依赖于传入的 <code>props</code>，即便有 <code>state</code> 也是属于自治范围，不会参与业务逻辑计算。这么一来就能尽可能地让 UI 层更加纯净，职责更单一。（当然这只是一种美好的愿望，实际上根据副作用切换组件状态或者其他业务逻辑操作还是会让业务逻辑下沉到 UI 层去）</p><p>让 UI 层尽可能地变得简单，而处理业务逻辑的部分就应该转移到 Redux 的 <code>action</code> 的部分中。<code>Reducer</code> 的部分也应该尽量纯净，不做业务处理。这样如果当需求有变化的时候，修改的部分就能尽可能地被缩小在 <code>action</code> 部分，同时在做项目移植时也会比较方便（基本 <code>action</code> 层很大可能会重写）。当然实际中并不可能剥离得非常干净，UI 层往往也会跟着一起变动，不过还是可以减少修改的范围。</p><h4 id="2-通用业务组件的封装与抽象"><a href="#2-通用业务组件的封装与抽象" class="headerlink" title="2. 通用业务组件的封装与抽象"></a>2. 通用业务组件的封装与抽象</h4><p>另一个就是根据项目需求提炼出通用的业务组件，比如短信验证码、可编辑 <code>label</code> 的表单控件、权限验证组件、搜索组件等。这类组件基本与业务相关，基本是某个组件库的再封装（比如 <code>antd</code>），这个也是现在许多同学平时会做的。这样在某一个业务中可以减少我们的开发量。具体的可以使用 HOC 等方法来进行封装和抽象（比如权限验证组件）。</p><p>提炼组件固然不错，但是也要避免过度封装。曾经在写 Vue 的时候封装了一个可配置的表单组件，结果当业务需要两个表单控件的互相控制以及按钮状态控制时就傻眼了。因此在设计封装组件时也要考虑到之后业务的变化。</p><p>以上便是最近这段时间的一些工作感悟，算是作为自己的一个备忘。编程原本的目的就是提高做事的效率，而提高开发的效率又是每一个程序员都要面临的难题。所以编程是一件十分有意思的事情，其中一点就是可以不断地挑战和提升自己。</p>]]></content>
    
    
    <categories>
      
      <category>随想杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>思考追根溯源的学习方法</title>
    <link href="/2019/02/07/2019/%E6%80%9D%E8%80%83%E8%BF%BD%E6%A0%B9%E6%BA%AF%E6%BA%90%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    <url>/2019/02/07/2019/%E6%80%9D%E8%80%83%E8%BF%BD%E6%A0%B9%E6%BA%AF%E6%BA%90%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>最近在《极客时间》上购买了 Winter 老师的<strong>重学前端</strong>这门课程，重新对自己的前端知识做一次查漏和补缺。(Winter 老师是谁？可以查看<a href="https://www.zhihu.com/question/20135455">这里</a>)在课程的开篇，Winter 老师提出了一种学习的方法：<em><strong>建立知识体系</strong></em> 以及 <em><strong>追根溯源</strong></em>。</p><p>建立知识体系相信大家都有自己的理解。特别是在前端这个知识点又多有分散的圈子里面更是如此。一幅知识体系的导图会不会让人在学习中迷失方向，当然这么庞大还在不断扩张的导图也会劝退不少人。</p><p>2015-2016 年的知识体系（引用自：<a href="https://www.jianshu.com/p/00baf1e65322">WEB前端知识体系脑图</a>)<br><img src="https://upload-images.jianshu.io/upload_images/228680-2cf062f3bcb8a985.jpg"></p><p>而追根溯源的方法个人感觉则更为重要。所谓追根溯源，即是寻找一个技术的源头、发明的背景、解决的问题以及发展的历史。毕竟计算机是一门解决实际问题的学科，当中用到的知识和解决问题的方法都是有据可循的。如果能通过追根溯源了解一个技术被发明的原因以及演变的历史，对我们理解和掌握这个技术都会有巨大的帮助。</p><span id="more"></span><p>之前在和小伙伴的交流中，小伙伴也有提出过这一学习方法。于是我自己也在复习对象和原型链的时候刻意尝试了一下并写了两篇笔记。</p><ul><li><a href="https://konata9.github.io/2018/12/17/%E3%80%8AJavaScript%20%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E4%BB%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%A4%8D%E4%B9%A0%E7%BB%A7%E6%89%BF/">《JavaScript 高级程序设计》 读书笔记–从原型链复习继承</a></li><li><a href="https://konata9.github.io/2018/12/11/%E3%80%8AJavaScript%20%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/">《JavaScript 高级程序设计》 读书笔记–创建对象方法的演化</a></li></ul><p>发现这样做确实对自己的理解有帮助，在反推了一下几种模式的演变以及解决的问题之后，发现这几种模式也更容易记住了（只要记住一两种剩下的就可以推出来）。在加入新公司之后，有幸做过一次 JavaScript 基础的技术分享，查了一下 JavaScript 这门语言发明的原因以及 ECMAScript 的变化过程，对之前不注意的坑又有了一个新的认识。可能这就是“知其所以然”的力量吧。</p><p>追根溯源的学习方法，虽然在学习的过程中会多花费一些精力在查找资料和自己动手推演的过程，但是一旦把一个知识点从源头“串”起来的话，那么这个知识点上的大多数问题都不再会是问题了，而与之相关的知识点也能触类旁通。</p><p>这一点在之前帮人面试前端的时候也有一些体会。一些年轻的面试者因为“生于” MVVM 的时代，对于操作 DOM 进行前端开发的“石器时代”并不了解。自然也就不熟悉最基本的 DOM 操作了。同样地，还有前端模块化的变迁。如果没有了解过引用 <code>script</code> 标签需要讲究顺序的时代，可能对模块化、作用域隔离等的理解就未必深刻。而这些如果是从 JQuery 时代过来的前端开发者或者是了解过这段历史的开发者的话，应该会理解起来非常方便（前提是有不断的思考和学习）。</p><p>当然，对“源头”不熟悉并不会影响我们日常开发。但只要想在前端方面深入，那么 DOM 操作、浏览器原理是自然逃不掉的。那么届时，就会对我们自身的提高带来阻碍。因为无论我们现在的框架有多么便利、打包工具有多么的方便，我们真正跑在浏览器上的仍然是“石器时代”的那些东西。</p><p>前端是如此，那么推演到编程这门学科上，自然便是数据结构与算法甚至是更底层的原理了。“想要技术上得到提高，就必须要了解计算机原理”这样的话相信只要是开发者就一定听过，我想这背后所说的就是要去追根溯源，把知识点“串”起来。如果我们可以以自己的方式，推演一遍的话，相信大部分的知识点肯定就能确实掌握了。正如老子在《道德经》中有说，“有道无术，术尚可求。有术无道，止于术。”</p>]]></content>
    
    
    <categories>
      
      <category>随想杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>程序员</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在 npm 上发布自己的包——typecheck</title>
    <link href="/2019/01/24/2019/%E5%9C%A8%20npm%20%E4%B8%8A%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8C%85%E2%80%94%E2%80%94typecheck/"/>
    <url>/2019/01/24/2019/%E5%9C%A8%20npm%20%E4%B8%8A%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8C%85%E2%80%94%E2%80%94typecheck/</url>
    
    <content type="html"><![CDATA[<p>如今做前端不可能不知道 npm，我们每天光是 <code>npm install</code> 这个命令可能就要敲不下十次。在 npm 上发布一个自己的包可能也是我们做前端的目标之一吧。最近在项目中封装了两个比较通用的库，所以就先挑一个简单的拿来尝试一下。</p><h2 id="关于-package-json"><a href="#关于-package-json" class="headerlink" title="关于 package.json"></a>关于 <code>package.json</code></h2><p>npm 项目的介绍文件主要就是 <code>package.json</code>。这个文件一般在我们创建项目时就会生成（除非你不使用 <code>npm init</code>）。文件的内容相信大家也不陌生。如果是做发布到 npm 上就要看一下前面的内容。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;@konata9/typecheck.js&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 项目名称，建议带上前缀现在 npm 上名字类似的包实在太多了。名称重复或太过相似就会被打回</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.1.0&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 每次发布的时候都必须更新版本号</span><br>  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;JavaScript typecheck&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;main&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./dist/index.js&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 项目的入口，我们每次 import 或 require 时找的那个入口文件</span><br>  <span class="hljs-attr">&quot;files&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;dist&quot;</span> <span class="hljs-comment">// 真正传到 npm 上的文件或文件夹。如果不设置，就是当前整个项目文件夹</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack --config webpack.config.js&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./node_modules/mocha/bin/mocha --compilers js:@babel/register test/typecheck.test.js&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;repository&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-comment">// GitHub 项目地址，写上的话会在页面的右边显示。如果是先在 GitHub 上建好项目后再 npm init 的话，这里会自动使用 GitHub 上 repo 的信息</span><br>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;git&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;git+https://github.com/Konata9/typecheck.git&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;keywords&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-comment">// 项目的关键词，有利于 npm 的搜索</span><br>    <span class="hljs-string">&quot;TypeCheck&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;typecheck&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;JavaScript&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;type&quot;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;author&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Konata9&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;license&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;MIT&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;bugs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://github.com/Konata9/typecheck/issues&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;homepage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://github.com/Konata9/typecheck#readme&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;devDependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;@babel/core&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^7.2.2&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;@babel/preset-env&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^7.2.3&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;@babel/register&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^7.0.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;babel-loader&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^8.0.5&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;chai&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^4.2.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;mocha&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^5.2.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;webpack&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^4.28.4&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;webpack-cli&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^3.2.1&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>下面就来看一下整个项目的结构。因为这是一个试水项目，因此结构也不是很复杂。不过麻雀虽小，五脏俱全。该有的应该也都有了。整个项目用到了 <code>webpack</code> 进行打包（使用了 ES6 语法）、<code>mocha</code> 进行了单元测试（单元测试真是好东西啊）。</p><span id="more"></span><p>项目的目录结构如下，项目源码非常简单在 GitHub 上 <a href="https://github.com/Konata9/typecheck">typecheck</a></p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs elm">typecheck<br>|<span class="hljs-comment">-- dist // 最终打包结果，也是上传到 npm 的文件</span><br>|<span class="hljs-comment">-- node_modules</span><br>|<span class="hljs-comment">-- src // 项目源码</span><br>  |<span class="hljs-comment">-- typecheck.js // 库文件</span><br>|<span class="hljs-comment">-- test // 测试文件</span><br>  |<span class="hljs-comment">-- typecheck.test.js // 测试文件</span><br>|<span class="hljs-comment">-- .babelrc</span><br>|<span class="hljs-comment">-- .gitignore</span><br>|<span class="hljs-comment">-- index.js // webpack 的入口文件</span><br>|<span class="hljs-comment">-- package.json // 项目的描述文件 npm init 生成</span><br>|<span class="hljs-comment">-- README.md</span><br>|<span class="hljs-comment">-- webpack.config.js</span><br></code></pre></td></tr></table></figure><h2 id="publish-时的注意事项"><a href="#publish-时的注意事项" class="headerlink" title="publish 时的注意事项"></a>publish 时的注意事项</h2><p>在把包发布到 npm 之前，有几件事情需要我们注意一下。首先我们要把源切回到 npm，不然是无法发布的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">先检查一下源是否正确</span><br>npm config get registry<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果源不对，就要切回 npm 源</span><br>npm set registry https://registry.npmjs.org/<br></code></pre></td></tr></table></figure><p>在这步完成后，我们就要去 <a href="https://www.npmjs.com/">npm</a> 官网上注册一个账号。注册完成后就可以在命令行里进行登陆（有账户的可以直接跳过）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看当前账户</span><br>npm whoami<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加用户，输入刚才之前在 npm 官网上注册的账户和密码</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">最后还要输一个邮箱，会显示在项目的页面上</span><br>npm adduser<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">发布包，第一次要加上 --access=publish (除非你出钱买了私有账户)</span><br>npm publish --access=public<br></code></pre></td></tr></table></figure><p>我自己在 <code>publish</code> 时，遇上过 403 或者 402 的问题。403 主要的原因是包名重复或者太接近，一般我们加上自己的用户名作为域就行；402 一般就是没有加上 <code>--access=public</code>。</p><p>发布完成后就可以去项目的发布页查看到发布的包了。<a href="https://www.npmjs.com/package/@konata9/typecheck.js">typecheck</a></p><p><img src="http://plx497mwo.bkt.clouddn.com/npm-sample.png"></p><h2 id="README-md-的书写"><a href="#README-md-的书写" class="headerlink" title="README.md 的书写"></a><code>README.md</code> 的书写</h2><p>README 的好坏决定别人对于项目采用程度。不过这方面我自己也没什么经验，就不多说了。网上倒是有不少关于文章可以参考，比如这篇文章 <a href="https://www.zhihu.com/question/29100816">如何写好Github中的readme？</a>。当然也可以参考一下 GitHub 上优秀项目的 Readme。</p>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>前端</tag>
      
      <tag>npm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不思考才是真正的危机</title>
    <link href="/2018/12/23/2018/%E4%B8%8D%E6%80%9D%E8%80%83%E6%89%8D%E6%98%AF%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%8D%B1%E6%9C%BA/"/>
    <url>/2018/12/23/2018/%E4%B8%8D%E6%80%9D%E8%80%83%E6%89%8D%E6%98%AF%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%8D%B1%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/think.png"></p><p>年末各大互联网企业结构调整（裁员）的消息一经放出，“资本寒冬”和“程序员如何渡过中年危机”又被关注。掘金、知乎上也能看到类似的讨论文章。作为一个准大龄程序员，自然我也同样有着焦虑和思考。</p><p>是转型管理还是钻研技术？又或者干脆考个公务员上岸？相信答案因人而异。最近在有幸当了回面试官，在面试了几位前端之后，我也有了一些自己的感悟。尽管没能找到渡过中年危机的答案，但是似乎发现了为何会陷入危机的原因——<strong>放弃了思考</strong>。</p><span id="more"></span><p><img src="/images/no-think.jpg" alt="卡兹最终放弃了思考"></p><p>前来面试的前端大多在 30 岁左右，大都有着 3 以上的工作经验，项目的经验也都不少，从 jQuery 的时代到 如今 MVVM 的时代。然而却都倒在了框架的原理、高级用法以及 JS 的基础上，其中一些印象令人深刻。</p><ul><li>有在项目中用了 React 和 React-router 却不明白前端路由和后端路由的区别以及弄混 render 和 DidMount 顺序的</li><li>有对于前端是否应该了解 Restful 规范表示疑问的</li><li>有对于 Array.map 返回值不确定的</li><li>有未来规划成为前端架构师却说还没了解过 Node 的</li><li>有把 Promise 认为就是 fetch 的</li></ul><p>而在 闭包、作用域、Redux&#x2F;Vuex、Event-Loop 等这些基础问题上，更是没有一个人能回答上来的，哪怕是最浅层次的概念。以至于我都被人当成是“钻牛角尖”了。</p><p>当被问到上面的一些问题时，面试者的反应基本都是“我平时在用，但是没怎么注意”。究其原因，便是这个<strong>没注意</strong>，而<strong>没注意</strong>的背后就是<strong>没有思考</strong>的体现。</p><p>“为什么这个项目用了 Redux&#x2F;Vuex ？”、“为什么 DOM 操作要放在 DidMounted&#x2F;Created 里做？”、“Promise 为什么会取代 Callback？” 等等。如果我们在做项目的时候多带个问号，相信在面对这些面试题时也不会是完全没有头绪。</p><p>有趣的是，当我们在玩 Dota、LOL 或者“农药”的时候，往往一局过后无论输赢都会复盘和总结一下，看看自己的数据然后想想自己的亮点与失误。如此往复，你就在不知不觉间从钻石成长为了星耀，从星耀成长为了王者。Coding 也是同样的道理，不是吗？</p><p>曾经看到一句签名，大意是：</p><blockquote><p>以现在人的努力程度，还根本还轮不到拼天赋</p></blockquote><p>我想这里的“努力”可能就是指在工作生活中自己的思考。这一次的经历也是很好的一面镜子，提醒着我思考的重要性。尽管程序员如何渡过中年危机的答案依旧未知，但至少知道了如果平时可以多问自己几个为什么的话，就能超越那些没有去思考的人。</p>]]></content>
    
    
    <categories>
      
      <category>随想杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>程序员</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《JavaScript 高级程序设计》 读书笔记--从原型链复习继承</title>
    <link href="/2018/12/17/2018/%E3%80%8AJavaScript%20%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E4%BB%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%A4%8D%E4%B9%A0%E7%BB%A7%E6%89%BF/"/>
    <url>/2018/12/17/2018/%E3%80%8AJavaScript%20%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E4%BB%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%A4%8D%E4%B9%A0%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<p>这一篇进入正题来复习一下 JavaScript 中对象的继承。“高程”中一共列举了 6 种继承的方式。看起来是有些吓人，但仔细梳理就能发现其中也是有一个演变过程的。这篇笔记就是我自己对这个过程的理解。如果有不足的地方，还希望各位可以指出。</p><p>再次安利一下“高程”，真的写得非常棒。有一定基础和项目经验的同学绝对要去看一看，能提高不少。</p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>在进入继承之前，我们再把一些基本概念复习一下。</p><h3 id="0-构造函数、原型对象、实例"><a href="#0-构造函数、原型对象、实例" class="headerlink" title="0. 构造函数、原型对象、实例"></a>0. 构造函数、原型对象、实例</h3><p>谈到对象，一定会出现这三个概念。在 JavaScript 中，<strong>原型对象</strong>不需要我们手动去定义，当我们定义一个类或者构造函数后，JavaScript 会自动生成对应的原型对象，我们可以通过 <code>prototype</code> 属性访问；我们写的 <code>function A()&#123;&#125;</code> 就是<strong>构造函数</strong>；而我们<strong>用 <code>new</code> 调用构造函数返回的值就是对象的实例</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-comment">// 构造函数：其实就是一般的函数。函数名大写只是一个约定规则而已。</span><br><span class="hljs-comment">// 事实上除了 new 之外，我们也可以像调用一般的函数一样使用。</span><br><span class="hljs-comment">// 在 ES6 中就是 Class 里面的 constructor</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">A</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = <span class="hljs-string">&#x27;a&#x27;</span><br>&#125;<br><br><span class="hljs-comment">// 原型对象：当我们定义对象的时候，就会生成一个对应的原型对象。</span><br><span class="hljs-comment">// 该函数的 prototype 属性就指向原型对象，这个就是原型链的精髓。</span><br>A.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br><br><span class="hljs-comment">// 实例: 用 new 调用构造函数的返回值。</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>()<br></code></pre></td></tr></table></figure><h3 id="1-原型链"><a href="#1-原型链" class="headerlink" title="1. 原型链"></a>1. 原型链</h3><p>下面再来看一下原型链的概念。原型链的概念我们一定不会陌生。那么就不多说了，直接上图。这是一个最基本的原型链，我们要仔细理解这张图并且搞清楚 <strong>实例</strong>、<strong>对象原型</strong>、<strong>构造函数</strong>以及与 <code>Object</code> 之间的关系。<br><img src="/images/prototype.png"></p><p>在复习完上面两个概念之后（特别是原型链），相信在后面理解继承的时候会有所帮助。如果在后面有所困惑的话，不妨回来看看基础概念。</p><p>下面就开始进入正题。</p><span id="more"></span><hr><h2 id="JavaScript-中的继承"><a href="#JavaScript-中的继承" class="headerlink" title="JavaScript 中的继承"></a>JavaScript 中的继承</h2><h3 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1. 原型链继承"></a>1. 原型链继承</h3><p>我们对上面基础的例子做一个拓展。再加入一个对象 <code>B</code>，我们同样画成图。<br><img src="/images/prototype2.png"></p><p><code>A</code> 和 <code>B</code> 是互相独立的两个对象（类），并且它们都是 <strong>继承</strong> 了 JavaScript 的对象之祖——<code>Object</code>对象。请注意，在一般的对象中，就已经存在了一个 <strong>对象</strong> 与 <strong><code>Object</code>对象</strong> 的继承关系了。</p><p>那么现在我们要让对象<code>B</code>去继承对象<code>A</code>，就可以模仿对象和<code>Object</code>的关系，修改<code>B</code>的原型对象的指向。<br><img src="/images/prototype3.png"></p><p>这么一来，<code>B</code>就可以顺着原型链访问到<code>A</code>了。由于现在<code>B.prototype = A.prototype</code>了，那么在<code>B.prototype</code>上做的任何修改都会影响到<code>A.prototype</code>了。所以我们再稍微调整一下，让 <code>B.prototype = new A()</code> 。</p><p>这样，完整的原型链继承的关系图就出来了。<br><img src="/images/prototype4.png"></p><p>简单的示例代码如下，小伙伴们可以在 Chrome 中试玩一下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">A</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = <span class="hljs-string">&#x27;a&#x27;</span> &#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">B</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span> = <span class="hljs-string">&#x27;b&#x27;</span> &#125;<br><br><span class="hljs-comment">// 不要这么做，因为修改 B 的 prototype 会影响 A 的 prototype</span><br><span class="hljs-comment">// B.prototype = A.prototype</span><br>B.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>()<br>B.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = B<br></code></pre></td></tr></table></figure><h4 id="对象的-constructor"><a href="#对象的-constructor" class="headerlink" title="对象的 constructor"></a>对象的 constructor</h4><p>在上面的示例代码中，最后一行我们对对象 B 的构造函数重新进行了赋值。这是因为，当我们改变了 <code>B.prototype</code> 的时候，会切断原来 B 的构造函数与 <code>B.prototype</code> 之间的联系。</p><p>虽然这个属性对我们的继承关系没有影响（<code>instanceof</code> 方法结果仍然正确）。但是从代码含义上来说，我们最好还是修改称为正确的指向。</p><p>另外，对于实例来说 <code>a.constructor.prototype === A.prototype // true</code>。即我们可以通过实例的构造函数去给对象原型添加属性和方法。尽管没人会推荐我们这么去做，但让属性指向正确的值会比较好。</p><p>和对象的创建一样，原型链的方法是比较简单的。但是也有一个明显的缺陷，就是“无法”对父类传不同的值。即 <code>B.prototype = new A(xx)</code> 时之后所有的 B 的示例都会带上这个值，因此就产生了局限性。</p><p>回想一下在创建对象时，我们是怎么解决这个问题的？</p><h3 id="2-构造函数继承"><a href="#2-构造函数继承" class="headerlink" title="2. 构造函数继承"></a>2. 构造函数继承</h3><p>在创建对象时，我们知道不同的实例在创建时只要向构造函数中传入不同的值，就会得到不同的值。那么回到继承上，为了解决原型链继承无法向父类传递不同值的问题，我们同样也需要借助构造函数。</p><p>在进入正题前，我们再看一下构造函数，然后想一下如果<strong>不用 new 调用构造函数会是怎样？</strong><br>下面是一个 <code>Person</code> 的构造函数。一般来说我们使用 <code>new</code> 关键字创建 <code>Person</code> 的实例。但是有没有想过，构造函数也是函数，如果我们不用 <code>new</code> 而是普通地调用会是怎么情况呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age, sex</span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sex</span> = sex<br>&#125;<br><br><span class="hljs-comment">// 直接调用会是怎么情况呢？</span><br><span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Kizunaai&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;female&#x27;</span>)<br></code></pre></td></tr></table></figure><p>熟悉 <code>this</code> 特性的小伙伴肯定能反应过来。独立调用函数时，若在非严格模式下，<code>this</code> 指向的是 <code>window</code>（浏览器环境）。那么我们看一下 <code>window</code>。<br><img src="/images/constructor.png"></p><p><code>window</code> 中果然就有了 <code>age</code> 这个属性，并且值为 2。也就是说，直接调用构造函数就相当于把构造函数中的属性赋给调用它的对象了。</p><p>好，趁热打铁，我们直接来看代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age, sex</span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sex</span> = sex<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">VTuber</span>(<span class="hljs-params">name, age, sex</span>)&#123;<br>  <span class="hljs-comment">// 调用 Person 的构造函数实际上就是把 Person 的值赋给 VTuber</span><br>  <span class="hljs-comment">// 在 ES6 中就是 super()</span><br>  <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name, age, sex)<br>&#125;<br><br><span class="hljs-keyword">var</span> kizunaai = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VTuber</span>(<span class="hljs-string">&#x27;kizunaai&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;female&#x27;</span>)<br><span class="hljs-keyword">var</span> luna = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VTuber</span>(<span class="hljs-string">&#x27;luna&#x27;</span>, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;female&#x27;</span>)<br><br>kizunaai.<span class="hljs-property">name</span> <span class="hljs-comment">// &#x27;kizunaai&#x27;</span><br>luna.<span class="hljs-property">name</span> <span class="hljs-comment">// &#x27;luna&#x27;</span><br></code></pre></td></tr></table></figure><p>我们在 Chrome 中分别打印一下之前的实例。可以看到 <code>VTuber</code> 的实例只是包含了 <code>Person</code> 的属性而已，而在原型链上两者是没有任何关系的。<br><img src="/images/constructor2.png"></p><p>所以再想一下，构造函数的方法其实真的是“继承”吗？因为对于“子类”来说，是没有办法<strong>调用父类原型</strong>上的方法的。而在用构造函数创建对象时我们就已经知道，把方法写在构造函数里显然不是一个好的解决方法。</p><h3 id="3-组合式继承"><a href="#3-组合式继承" class="headerlink" title="3. 组合式继承"></a>3. 组合式继承</h3><p>既然原型链和构造函数正好能弥补互相之间的缺陷，组合起来我们能愉快地进行继承了。也没什么新的知识点，就直接上代码了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age, sex</span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sex</span> = sex<br>&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> say hello ~`</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">VTuber</span>(<span class="hljs-params">name, age, sex</span>)&#123;<br>  <span class="hljs-comment">// 构造函数保证了不同值的传递</span><br>  <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name, age, sex)<br>&#125;<br><br><span class="hljs-comment">// 原型链保证了方法的传递（还有意义上）</span><br><span class="hljs-title class_">VTuber</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br><span class="hljs-title class_">VTuber</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">VTuber</span><br><br><span class="hljs-keyword">var</span> kizunaai = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VTuber</span>(<span class="hljs-string">&#x27;kizunaai&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;female&#x27;</span>)<br><span class="hljs-keyword">var</span> luna = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VTuber</span>(<span class="hljs-string">&#x27;luna&#x27;</span>, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;female&#x27;</span>)<br><br>kizunaai.<span class="hljs-property">name</span> <span class="hljs-comment">// &#x27;kizunaai&#x27;</span><br>luna.<span class="hljs-title function_">sayHello</span>() <span class="hljs-comment">// &#x27;luna say hello ~&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="4-寄生组合式继承"><a href="#4-寄生组合式继承" class="headerlink" title="4. 寄生组合式继承"></a>4. 寄生组合式继承</h3><p>组合式继承是我们最常用的继承方法，几乎可以说是满足了我们的需求。硬要挑刺的话，也就是父类的构造函数调用两次的问题了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-comment">// 以之前的代码为例</span><br><span class="hljs-comment">// 第一次在子类的构造函数中调用</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name, age, sex)<br><br><span class="hljs-comment">// 第二次在建立原型链时调用</span><br><span class="hljs-title class_">VTuber</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br></code></pre></td></tr></table></figure><p>其中第一次是一定省不掉的，要下功夫的话就是在第二次建立原型链的时候了。还是以前面的代码为例，我们就这么继承，数据结构会是怎么样的？<br><img src="/images/combine.png"></p><p>可以看到在 <code>VTuber.prototype</code> 上也有 <code>name, age, sex</code> 三个属性，但实际上这三个属性根本没有意义。那么解决的思路就有了，我们需要借助一个空的对象来搭一座桥。（千万别说让 <code>VTuber.prototype = Person.prototype</code> 了，理由参考原型链那部分）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age, sex</span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sex</span> = sex<br>&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> say hello ~`</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">VTuber</span>(<span class="hljs-params">name, age, sex</span>)&#123;<br>  <span class="hljs-comment">// 构造函数保证了不同值的传递</span><br>  <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name, age, sex)<br>&#125;<br><br><span class="hljs-comment">// 我们要借用一个空对象作为过渡</span><br><span class="hljs-comment">// VTuber.prototype = new Person()</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">A</span>(<span class="hljs-params"></span>)&#123;&#125;<br>A.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br><span class="hljs-title class_">VTuber</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>()<br><br><span class="hljs-title class_">VTuber</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">VTuber</span><br><br><span class="hljs-keyword">var</span> kizunaai = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VTuber</span>(<span class="hljs-string">&#x27;kizunaai&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;female&#x27;</span>)<br><span class="hljs-keyword">var</span> luna = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VTuber</span>(<span class="hljs-string">&#x27;luna&#x27;</span>, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;female&#x27;</span>)<br><br>kizunaai.<span class="hljs-property">name</span> <span class="hljs-comment">// &#x27;kizunaai&#x27;</span><br>luna.<span class="hljs-title function_">sayHello</span>() <span class="hljs-comment">// &#x27;luna say hello ~&#x27;</span><br></code></pre></td></tr></table></figure><p>上面我们借用了一个 <code>A</code> 来打了个桥。这样一来就在原型链上就没有多余的属性了。（其实两次构造函数是肯定要调的，只是第二次调谁的问题）<br><img src="/images/combine2.png"></p><p>而这种搭桥的方式，在“高程”中也被称为是原型式继承。其中关于原型式和寄生式分别和原型链、构造函数相对应，感觉没有这两种直观而且也不常用（个人感觉）所以就不做展开了，有兴趣的小伙伴还是推荐去阅读“高程”。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>至此，有关于继承的笔记就到此为止。这一篇顺着对象的原型链的概念开始，介绍了 JavaScript 中对象继承的几种方式。其中组合继承的方式是我们最常见也是用的最广的，我们需要好好了解一下。</p><p>在看书的过程中，像这样给自己抛点问题，找一找方法间的演变脉络即很有趣也很容易理解。不知道各位小伙伴有什么好的学习方法呢？不妨互相交流一下吧～</p>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>前端</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo中加入Gitalk的问题总结</title>
    <link href="/2018/12/16/2018/hexo%E4%B8%AD%E5%8A%A0%E5%85%A5Gitalk%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2018/12/16/2018/hexo%E4%B8%AD%E5%8A%A0%E5%85%A5Gitalk%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>最近因为换了新电脑，于是把 hexo 博客做了一个迁移。就借此机会顺便给自己的博客加入 Gitalk 作为评论的功能。但是在加入的过程中，遇到了几个问题，留作记录和备忘。</p><h3 id="1-在-hexo-中引入-Gitalk"><a href="#1-在-hexo-中引入-Gitalk" class="headerlink" title="1. 在 hexo 中引入 Gitalk"></a>1. 在 hexo 中引入 Gitalk</h3><p>我的博客使用的是 NexT 主题，在 NexT 主题下引入 Gitalk 具体可以参考这篇文章 <a href="https://asdfv1929.github.io/2018/01/20/gitalk/">Hexo NexT主题中集成gitalk评论系统</a>。引入方式很简单，照着这篇文章做就行。</p><p>只是有一点需要注意的是，文章中提到的文件夹的位置是在 <code>themes/next/</code> 下的。</p><blockquote><p>新建&#x2F;layout&#x2F;_third-party&#x2F;comments&#x2F;gitalk.swig文件，并添加内容</p></blockquote><p>比如像这步操作，就是要在 <code>themes/next</code> 文件夹下进行的。因为原文没有明说，所以一开始我是建在了根目录下（我一开始可能也没理解 T T）</p><h3 id="2-Gitalk-引入后控制台-422-错误的解决方式"><a href="#2-Gitalk-引入后控制台-422-错误的解决方式" class="headerlink" title="2. Gitalk 引入后控制台 422 错误的解决方式"></a>2. Gitalk 引入后控制台 422 错误的解决方式</h3><p>在上面引入 Gitalk 后，打开博客第一次会需要我们进行 GitHub 的认证，如果我们是按照官网（下面代码）或者网上其他的博客引入时，就会出现 <code>控制台 422</code> 的问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> gitalk = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Gitalk</span>(&#123;<br>  <span class="hljs-attr">clientID</span>: <span class="hljs-string">&#x27;GitHub Application Client ID&#x27;</span>,<br>  <span class="hljs-attr">clientSecret</span>: <span class="hljs-string">&#x27;GitHub Application Client Secret&#x27;</span>,<br>  <span class="hljs-attr">repo</span>: <span class="hljs-string">&#x27;GitHub repo&#x27;</span>,<br>  <span class="hljs-attr">owner</span>: <span class="hljs-string">&#x27;GitHub repo owner&#x27;</span>,<br>  <span class="hljs-attr">admin</span>: [<span class="hljs-string">&#x27;GitHub repo owner and collaborators, only these guys can initialize github issues&#x27;</span>],<br>  <span class="hljs-comment">//id: location.pathname 官方文档代码。由于 GitHub Issue Label 50 个字符的长度的限制，直接引用的话页面就会报 422 错误因此需要把这里 md5 化</span><br>  <span class="hljs-attr">id</span>: <span class="hljs-title function_">md5</span>(location.<span class="hljs-property">pathname</span>),    <br>  <span class="hljs-attr">distractionFreeMode</span>: <span class="hljs-literal">false</span> <br>&#125;)<br><br>gitalk.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;gitalk-container&#x27;</span>)<br></code></pre></td></tr></table></figure><p>问题的原因很简单，是由于 GitHub 对于 Issue Label 的 50 个字符限制，我们只需要让 <code>id</code> 小于 50 个字符即可。</p><p>网上给出的方法是使用 md5，但是 md5 的 js 库很不巧在 <code>unpkg</code> 上似乎没有，不能引用网上资源只能下载下来本地引入。但是网上的解决方法都没给出 <code>js</code> 文件本地引入的位置。害的我搞了很长时间。要在 NexT 中引入静态文件的话，文件我们可以放在 <code>themes/next/source/js/src</code> 下；而 html 中，是在 <code>themes/next/layout/_layout.swig</code> 中引入。只要注意引入位置和路径即可。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">...<br>// 注意引入的位置和路径<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/js/src/md5.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span> <br>&#123;% include &#x27;_third-party/comments/index.swig&#x27; %&#125;<br>...<br></code></pre></td></tr></table></figure><p>这么一来，我们重新编译就能解决 Gitalk 的问题了。这样一来，就可以愉快地让来看博客的人发表评论了～效果如下：<br><img src="/images/gitalk-sample.png"></p>]]></content>
    
    
    <categories>
      
      <category>程序学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>Gitalk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《JavaScript 高级程序设计》 读书笔记--创建对象方法的演化</title>
    <link href="/2018/12/11/2018/%E3%80%8AJavaScript%20%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/"/>
    <url>/2018/12/11/2018/%E3%80%8AJavaScript%20%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>最近在复习《JavaScript 高级程序设计》看到对象一章，才发现自己在对象的创建和继承上的认识是多么的不足。于是写下这一篇作为自己的读书笔记，同时也加强自己的理解。</p><p>在自己真正有了一些项目经验后，再回头看，不由地觉得这本书写得真是好。还记得在前端小白的时代，看“高程”简直是不知所云，为什么要讲这么些基础语法呢？而且还十分枯燥。如今再看，原来是字字珠玑，把 JavaScript 这门语言的特性和细节全都交代得一清二楚。所以对于已经工作一两年的前端小伙伴，赶紧再去看看“高程”一定会有所收获的。</p><p>那么下面就进入正题吧。</p><hr><p>说到在 JavaScript 中要创建一个对象，我们最先应该会想到下面两种方法。</p><ol><li>对象字面量： <code>let a = &#123;&#125;</code>，用一对花括号解决一切</li><li>创建构造函数： <code>function A()&#123;&#125; / Class A &#123;&#125;</code>，用一个 <code>new</code> 解决一切</li></ol><p>在“高程”中一共给我们整理出了 7 种创建对象的方法。别怕，虽然数量上有很多，但其实基本都为了解决使用过程中的问题的，我们顺着问题去理解就很容易了。</p><h3 id="0-花括号"><a href="#0-花括号" class="headerlink" title="0. 花括号"></a>0. 花括号</h3><ul><li>产生的问题： 代码重复。</li></ul><p>创建一个类，最简单的莫过于一对花括号。就像下面这样，简单、直接。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> p1 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;KizunaAi&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;f&#x27;</span>,<br>  <span class="hljs-attr">getName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是，当我们要创建 10 个类似于 <code>p1</code> 的对象时，代码的重复就成了一个头痛的事情了。于是，我们就利用函数和 <code>Object</code>，搭建出工厂模式。</p><span id="more"></span><h3 id="1-工厂模式"><a href="#1-工厂模式" class="headerlink" title="1. 工厂模式"></a>1. 工厂模式</h3><ul><li>解决问题：重复代码问题。只要定义一次，就能创建相同格式的对象。</li><li>产生的问题：没有对象类型，实例都是 <code>Object</code> 类型；内部方法重复生成会占空间。</li></ul><p>在<strong>普通函数</strong>内包装了一个 <code>Object</code>，然后通过 <code>new Object()</code> 返回我们要的实例。在软件工程中是个经典的模式，不过现在基本被构造函数模式代替了。</p><p>示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">CreatePerson</span>(<span class="hljs-params">name, age, sex</span>)&#123;<br>  <span class="hljs-comment">// 在函数内部生成 Object 的实例</span><br>  <span class="hljs-keyword">let</span> o = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>()<br>  o.<span class="hljs-property">name</span> = name<br>  o.<span class="hljs-property">age</span> = age<br>  o.<span class="hljs-property">sex</span> = sex<br><br>  o.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> o<br>&#125;<br><br><span class="hljs-comment">// 普通调用函数方法获取实例</span><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-title class_">CreatePerson</span>(<span class="hljs-string">&#x27;KizunaAi&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;f&#x27;</span>)<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-title class_">CreatePerson</span>(<span class="hljs-string">&#x27;Luna&#x27;</span>, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;f&#x27;</span>)<br></code></pre></td></tr></table></figure><p>工厂模式彻底解决了代码重复的问题，但是留下实例无法确定对象类型的问题，这个主要是因为实例的 <code>constructor</code> 函数指向的是 <code>Object</code>，为了解决这个问题，就有了后面的构造函数方法。</p><h3 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2. 构造函数"></a>2. 构造函数</h3><ul><li>解决问题：构造函数 <code>new</code> 出来的实例，有对象类型。即可以使用 <code>instanceof</code> 方法进行判断。</li><li>产生的问题：方法（函数）定义在构造函数内部时，每次创建实例时都会重复创建方法，因此仍然会有资源占用的问题。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age, sex</span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sex</span> = sex<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 我们最常用的 new 来啦</span><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;KizunaAi&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;f&#x27;</span>)<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Luna&#x27;</span>, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;f&#x27;</span>)<br></code></pre></td></tr></table></figure><p>构造函数方法解决了实例的对象类型问题，也基本取代了工厂模式。但是对于每个实例的会创建各自独立的方法仍然没有解决。这个问题就交给了原型模式。</p><h3 id="3-原型模式"><a href="#3-原型模式" class="headerlink" title="3. 原型模式"></a>3. 原型模式</h3><ul><li>解决问题：实例的方法可以共享，可以避免资源占用的问题。</li><li>产生的问题：属性也会共享，那么一旦有一个实例修改了属性，所有的实例对应的属性也会被修改。</li></ul><p>我们创建的每个函数都有一个 <code>prototype</code> 属性，这个属性的用处就是可以让所有的实例共享属性和方法。这样一来，我们把方法挂到 <code>prototype</code> 上就能避免实例方法的重复创建的问题了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>)&#123;&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;KizunaAi&#x27;</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">age</span> = <span class="hljs-number">2</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sex</span> = <span class="hljs-string">&#x27;f&#x27;</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span><br>&#125;<br><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br><span class="hljs-comment">// p1.name = KizunaAi</span><br></code></pre></td></tr></table></figure><p>原型模式解决了实例方法独自创建的问题，但是原型上的公共属性却也会被波及，但这个其实并不是什么问题。到这里基本问题就基本都解决了，只要优化一下即可。</p><h3 id="4-组合模式（构造-原型）"><a href="#4-组合模式（构造-原型）" class="headerlink" title="4. 组合模式（构造 + 原型）"></a>4. 组合模式（构造 + 原型）</h3><p>所以顺着上面的问题，就能明白为什么说属性要放在构造函数里，方法要挂到 <code>prototype</code> 上了。而这么一来，也就是我们用的最多的书写类的方法了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age, sex</span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sex</span> = sex<br>&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span><br>&#125;<br><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;KizunaAi&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;f&#x27;</span>)<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Luna&#x27;</span>, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;f&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>尽管高程中创建对象有 7 中模式，但顺着问题就能发现<strong>组合模式</strong>解决了前面留下的所有问题。可以说是最合适的模式了。之后的模式其实都是前面模式的衍生和变种，感觉平时也用不上也就不再展开了。</p><p>说实在的，在日常的工作中会用一对花括号和一个 <code>new</code> 基本就能解决 90% 的问题了。真的要自己去了解为什么这么做的情况并不多（我自己除了在 Node 中会写写类，在前端感觉真的用不到，除非是自己写框架吧）</p><p>但有时候去了解一下常用的方法背后的故事，不也是一件挺有意思的事情吗？</p><hr><p>其实我原本主要是去看继承的（这一块平时用得少，一直是一知半解的状态），在看的过程中发现继承与对象创建的关系十分密切。看完对象的创建再看继承会容易理解很多。所以下一篇就是继承的学习笔记了。</p>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>前端</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用node.js制作MySQL表结构文档</title>
    <link href="/2018/03/25/2018/%E5%88%A9%E7%94%A8node-js%E5%88%B6%E4%BD%9CMySQL%E8%A1%A8%E7%BB%93%E6%9E%84%E6%96%87%E6%A1%A3/"/>
    <url>/2018/03/25/2018/%E5%88%A9%E7%94%A8node-js%E5%88%B6%E4%BD%9CMySQL%E8%A1%A8%E7%BB%93%E6%9E%84%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<p>对于一个项目来说，数据库表结构的设计是比较重要的一环。从程序开发的流程上来说，应该先设计表再着手进行开发。不过随着技术的发展，很多后端语言都有表结构的映射了。因此，对于表结构的设计就转变成了类结构的设计了。这么做无疑是节省了人工成本，但带来的负面影响是没有以前设计流程中的表结构的文档了。</p><p>在最近的一个项目中，恰好就遇见了需要表结构文档的情况。虽说可以直接看类定义，但是这样毕竟不是最直观的。不过要对着类定义来做文档，又很花费精力，同时文档与代码的同步性也是一个很严重的问题。在上家公司由于文档往往都是有延迟或者间隔的，导致一旦发生什么，就只能对着源码来工作。</p><p>所以对应着这样的需求，自然就有了制作相关小工具的想法了。主要的需求就是——生成比较容易阅读的表结构文档。</p><span id="more"></span><p>作为一个坚定的JS爱好者，二话不说就拿着Node上了。因为后端在做映射的时候肯定会生成建表的SQL，那么我只要对这SQL进行解析的就完事了嘛~但是转念一想，解析SQL文件根本就没必要啊！既然是拿表的结构，那么直接从数据库里面拿不就好了嘛！</p><p>整体的流程大致如下：</p><ol><li>连接MySQL，执行相关SQL语句</li><li>把SQL获取到的结果按照对应的格式输出成文档(表结构与索引相关信息）</li></ol><p>为此我们需要下面几个库来帮我们</p><ol><li><a href="https://github.com/mysqljs/mysql">mysql</a> 用于连接MySQL以及执行相关SQL语句</li><li><a href="https://github.com/SheetJS/js-xlsx">xlsx</a> 用于导出Excel</li><li><a href="https://github.com/caolan/async">async</a> 用于执行批量操作</li></ol><p>逻辑并不是很复杂，而且这些库相信很多同学也都用过，所以也就不在这里展开了。<br>还是老样子，先来看看整体的实现效果。<br><img src="https://upload-images.jianshu.io/upload_images/3101443-5aa7020acfb4c8d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="example.png"></p><p>执行<code>npm run start</code>就会生成出含有表结构以及索引相关信息的Excel文档了。</p><ul><li>没有样式是因为<code>xlsx</code>没法对Excel的单元格进行编辑。不过相比起手工做表结构，添加一点样式的工作量应该是少很多了。</li></ul><p>目前生成出的字段都是我根据自己目前项目需要所抽取的，各位也可以根据自己的需要来进行设置。<br>设置的方法可以查看<a href="https://github.com/Konata9/mysql-doc">项目</a>的Readme。</p><p>项目地址在这里：<a href="https://github.com/Konata9/mysql-doc">mysql-doc</a><br>有不足和需要改进的地方也请各位多多指点，如果正好有帮上各位的忙也请不要吝啬点个赞呗~</p>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Vue+PouchDB做一个本地的ToDoList</title>
    <link href="/2018/02/22/2018/%E4%BD%BF%E7%94%A8Vue-PouchDB%E5%81%9A%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0%E7%9A%84ToDoList/"/>
    <url>/2018/02/22/2018/%E4%BD%BF%E7%94%A8Vue-PouchDB%E5%81%9A%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0%E7%9A%84ToDoList/</url>
    
    <content type="html"><![CDATA[<p>首先在这里给大家拜个晚年，祝大家新年愉快，编程功力节节高升~~</p><p>我自己有制定年度规划的习惯，之前也一直在用OneNote在做。OneNote虽然好用，可是没有相关统计功能。这样就不容易把握计划制定的是否合理。于是就趁着放假，顺手做一个简单的ToDoList小程序。</p><h5 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h5><p>这个项目就先叫他EasyTodoList吧。不过先别急着动手，先利用脑图简单整理一下需求。这样既可以清楚地知道需要哪些东西以及从哪下手，也可以防止在做的过程中歪楼。<br><img src="http://upload-images.jianshu.io/upload_images/3101443-ab9639355702fea7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="EasyTodoList 项目需求"></p><span id="more"></span><h5 id="技术选择"><a href="#技术选择" class="headerlink" title="技术选择"></a>技术选择</h5><p>技术方面<code>Vue</code>和<code>vue-router</code>相信不会有什么问题，毕竟是现在的主流之一。所以这一次的主要问题是在存储的选择上。</p><p>首先，先去掉MySQL和MongoDB，因为这仅仅只是一个小项目，数据量也不是很大。因此没有必要上后端的东西。<br>那么剩下就是客户端存储了。在客户端存储中，storage只能进行简单的<code>key-value</code>存储，没有查询和统计的功能；而WebSQL虽然用起来很爽，但已经是不在维护的项目了，所以也不推荐使用了；最后就是IndexedDB了，IndexedDB是目前比较推荐的客户端存储技术了。类似于MondgoDB的NoSQL数据库。因为原生API相对繁琐，为了简化开发，这里就使用二次开发的<a href="https://pouchdb.com/">PocuhDB</a>来作为客户端存储（API调用很简单，参考一下官网就能搞定）。（关于客户端存储的相关内容可以查看我之前的文章<a href="https://www.jianshu.com/p/a363b60cefcd">客户端存储技术</a>）</p><p>需要注意的是，IndexedDB也是客户端存储的一种，自然也有客户端存储的特性。那么当改变浏览器或者改变监听端口时，之前存储的数据自然也就消失不见了（相当于重新换了个数据库），这在使用上或多或少带来了不便。</p><h5 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h5><p>先来看一下最终做出来的效果。<br><img src="http://upload-images.jianshu.io/upload_images/3101443-4ee06c0f00c99327.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图"></p><p>整个项目比较简单，只有总览以及任务列表两个页面。在添加了任务分类以及分类下的任务后，在总览页面就会有相关统计。在设置任务完成后，也会统计完成与未完成的任务的比例以及图表。图表部分是用Echarts来进行绘制的，绘制的方法也可以参考<a href="http://echarts.baidu.com/">官方文档</a>。</p><p>因为代码量不多也就不在这里多啰嗦了。详细代码可以来我的GitHub上参观指导。<br>项目地址：<a href="https://github.com/Konata9/EasyTodoList">EasyTodoList</a></p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>整个项目在技术上没有难点，是个很容易撸的项目。结合了前端存储（IndexedDB），虽然简化了开发也带来了使用上的不便。不过作为一个练手的项目应该是比较不错的了。因为存储的问题非常尴尬，所以接下来考虑移植到Electron上，直接做成一个App来避免这个问题。</p>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>前端</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用jsdoc为vue项目生成漂亮的文档</title>
    <link href="/2018/01/26/2018/%E5%88%A9%E7%94%A8jsdoc%E4%B8%BAvue%E9%A1%B9%E7%9B%AE%E7%94%9F%E6%88%90%E6%BC%82%E4%BA%AE%E7%9A%84%E6%96%87%E6%A1%A3/"/>
    <url>/2018/01/26/2018/%E5%88%A9%E7%94%A8jsdoc%E4%B8%BAvue%E9%A1%B9%E7%9B%AE%E7%94%9F%E6%88%90%E6%BC%82%E4%BA%AE%E7%9A%84%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<p>jsdoc是前端自动生成文档所常用的工具。我们只要按照jsdoc的语法来书写注释就能顺利的生成一片很漂亮的文档。</p><p>只是jsdoc针对的是<code>js</code>文件，对于<code>.vue</code>文件似乎就有些无能为力了。不过既然<code>vue</code>这么人气，相信一定也会有相应的工具。在找了一圈之后，果然找到了一位前辈写的<code>jsdoc-vue</code>。</p><p>在研究了一下之后，发现这个工具主要解决了jsdoc不认<code>.vue</code>文件的问题。虽然可以让<code>.vue</code>文件自动生成文档，但生成出的文档样式却并不好看。于是就fork过来改造了一下。</p><p>废话不多说，先上一张生成的文档截图。</p><span id="more"></span><p>github地址：<a href="https://github.com/Konata9/jsdoc-vue">jsdoc-vue 改造版</a><br><img src="http://upload-images.jianshu.io/upload_images/3101443-6df83ab7a3834c37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="vue文档截图.png"></p><h5 id="改造的部分主要有以下几点："><a href="#改造的部分主要有以下几点：" class="headerlink" title="改造的部分主要有以下几点："></a>改造的部分主要有以下几点：</h5><ol><li>使用了<code>jsdoc</code>字典，因此可以使用<code>jsdoc</code>自带的标签来进行编写。这样也便于生成需要的模板。</li><li>生成文档采用了<a href="https://github.com/Nijikokun/minami">minami</a>模板</li><li>升级了 vue-template-complier 和 jsdoc 模块</li></ol><h5 id="安装使用方法"><a href="#安装使用方法" class="headerlink" title="安装使用方法"></a>安装使用方法</h5><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">git</span>@github.com:Konata9/jsdoc-vue.git<br><br>npm install <br></code></pre></td></tr></table></figure><p>这个改造后的版本我自己用着还算比较满意，比较重要的如<code>props</code>和<code>components</code>组件都可以利用jsdoc自带的语法比较清楚的表示出来。</p><p>如果各位喜欢的话，希望可以点一个star。当然，如果有改进的地方也希望各位可以指点一下。</p>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>前端</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>router-view 复用时组件不刷新的解决办法</title>
    <link href="/2017/12/02/2017/router-view%20%E5%A4%8D%E7%94%A8%E6%97%B6%E7%BB%84%E4%BB%B6%E4%B8%8D%E5%88%B7%E6%96%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <url>/2017/12/02/2017/router-view%20%E5%A4%8D%E7%94%A8%E6%97%B6%E7%BB%84%E4%BB%B6%E4%B8%8D%E5%88%B7%E6%96%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>在使用Vue-router做项目时，会遇到如<code>/serviceId/:id</code>这样只改变<code>id</code>号的场景。由于router-view是复用的，单纯的改变<code>id</code>号并不会刷新router-view，而这并不是我们所期望的结果。</p><p>当然，我们可以在点击事件上加上<code>router.go(0)</code>，强制刷新整个页面来满足效果。但页面整体的刷新会使体验下降，并且作为个人也不是很能接受这样的方法。在查阅了一些资料后，发现可以有以下两种方法可以解决问题。</p><h4 id="1-使用watch方法"><a href="#1-使用watch方法" class="headerlink" title="1. 使用watch方法"></a>1. 使用watch方法</h4><p>watch方法据说是官方推荐的方法（抱歉，我没好好看文档）。当<code>id</code>发生变化时，’$route’也会相应地发生变化，因此可以通过watch的方法来进行操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">watch</span>: &#123;<br>  <span class="hljs-string">&#x27;$route&#x27;</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) &#123;<br>    <span class="hljs-comment">// console.log(to)</span><br>    <span class="hljs-comment">// console.log(from)</span><br>    <span class="hljs-comment">// 我这里还是用了Vuex，不过应该不影响理解</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;updateActiveTemplateId&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">params</span>.<span class="hljs-property">templateId</span>) <br>    <span class="hljs-comment">// 通过更新Vuex中的store的数据，让数据发生变化</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getTemplateById</span>()<br>  &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><span id="more"></span><h4 id="2-添加一个随机数"><a href="#2-添加一个随机数" class="headerlink" title="2. 添加一个随机数"></a>2. 添加一个随机数</h4><p>通过给<code>router-view</code>添加一个动态变化的参数，让Vue认为这个组件每一次都是一个新组件，从而重新刷新。<br>这个个人感觉是一个十分巧妙和优雅的方法，但是我这次并没有用（捂脸）。具体的实现如下：</p><blockquote></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;router-view :key=<span class="hljs-string">&quot;key&quot;</span>&gt;&lt;/router-view&gt;<br><span class="hljs-attr">computed</span>: &#123;<br>    <span class="hljs-title function_">key</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">name</span> !== <span class="hljs-literal">undefined</span>? <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">name</span> + +<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(): <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span> + +<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>具体的做法可以参考这篇文章：<a href="https://segmentfault.com/a/1190000009275424#articleHeader16">手摸手，带你用vue撸后台 系列一(基础篇)</a></p>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>前端</tag>
      
      <tag>Vue</tag>
      
      <tag>vue-router</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
